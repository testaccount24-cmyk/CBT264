         TITLE 'LOOK -- DISPLAY VIRTUAL MEMORY -- 64-BIT VERSION'
*
** -------------------------------------------------------------------
**   This program is not re-entrant, but it should be linkedited
**   as REUS (reusable), and it has to be SETCODE AC(1), run
**   from an APF-authorized load library, and marked in the
**   AUTHCMD NAMES list of the IKJTSOxx PARMLIB member.
** -------------------------------------------------------------------
**   This program does not change storage, but lets you look at
**   storage in any active address space.
** -------------------------------------------------------------------
**   This version has been fixed by Joe Reichman, to handle 64-bit
**   addresses.  When doing indirect addressing for a 64-byte address,
**   use the letter G instead of the letter J.
**
**   Examples:   G+1B8, G+10
**
**   How does indirect addressing work for 64-byte addresses?
**   In this case, LOOK will go to the location indicated, and regard
**   the first 8 bytes there as an address.  And then it will attempt
**   to access the storage at that address, displaying its contents.
**   This is just like the action of J, which does the same thing for
**   4-byte addresses (or 3-byte addresses, for that matter).
** -------------------------------------------------------------------
**   This version of LOOK has been revised by Joe Reichman to allow
**   operation when VSM ALLOWUSERKEY(NO) is set, in the PARMLIB
**   member DIAGxx.  For cross-memory storage browsing, the SCHEDULE
**   macro has been replaced by IEAMSCHD, so this version of the
**   program may not work on old MVS systems.  However, IEAMSCHD has
**   been here at least since ESA.  Its parameter SYNCH=YES has been
**   in existence since OS/390 Release 1.3 (but not before that).
**   (Since OS/390 1.3 was the first Y2K-compliant version of MVS, it
**   is not likely that anyone is running something earlier, in
**   production.)
**
**   From z/OS 2.4 and onward, user key CSA allocation will be
**   prohibited.  But this version of LOOK should still work there.
**
**   THIS VERSION OF LOOK REQUIRES APF-AUTHORIZATON, ALWAYS, BECAUSE
**   ITS WORKING STORAGE IS NOW OBTAINED IN KEY 0, NOT IN A USER KEY.
** -------------------------------------------------------------------
**   LOOK requires assembly together with the CBMACS module, so that
**   it can format many system control blocks.  The LOOK module is the
**   "driving code", which can be assembled together with different
**   versions of CBMACS depending on any specialized needs that you
**   have, to format specific control blocks.  The CBMACS we have
**   packaged with CBT File 264, will already format many standard
**   z/OS (OS390, MVS) control blocks, but you may want to create
**   your own versions of CBMACS.
**
**   Please note:  CBMACS will only format "real data" in macros,
**   so when an IBM macro contains:   label   DS  0CLx   or similarly,
**   label  DS  0XLx  then CBMACS will not display that field.  You
**   may want to create your own altered versions of IBM macros, but
**   we can't publish them for licensing reasons.  Formatting in
**   CBMACS also depends on the data type (such as C, X, A, F, etc.)
**   You may want to alter an IBM macro from  DS CL5 to DS XL5, so
**   that the data will display in hex, instead of showing a dot,
**   when that data is not a displayable value.
**
**   Formatting is turned off, using the ONULL command in LOOK.
**   Formatting is turned on, using the O command, followed by
**   the name of the control block:
**   Examples:   OTCB  OPSA  OCVT
**
**   If the control block (to be formatted) does not contain an
**   eyecatcher, such as "TCB" (field TCBTCBID in macro IKJTCB),
**   then you can not format it automatically, but you need to run
**   an Oblkid command to do the formatting.
**   -----------------------------------------------------------------
**   The HELP for LOOK is only one screen, accessible if you
**   press PF1.  It is short and concise, but you should study it.
**   (Pretty much everything, is there.  You just have to look.)
**   -----------------------------------------------------------------
**
**       This version of LOOK supports multiple address space
**       investigation.  Overtype the address space number, at
**       the upper right side of the screen:
**
**       Example:    CURRENT ASID= 0024
**                                 ----   (overtype hex asid number)
**
**       (There is quite a bit of validity checking built into this
**       overtyping process.)
**
**       THIS VERSION IS CONFIGURED TO RUN AND RESIDE ABOVE THE LINE,
**       AND IS THE 31-BIT VERSION.
**
** -------------------------------------------------------------------
**
**   Original code for this program was largely from Guy Albertelli.
**
** -------------------------------------------------------------------
**   VERSION 1.1 CHANGES (6/1/88):                                  1.1
**      - CORRECT ESTAE AND FRR ATTEMPTS TO DETERMINE HOW MUCH      1.1
**        DATA WAS MOVED.                                           1.1
**      - GIVE MESSAGES IF DATA WAS NOT MOVED, DISTINGUISH BETWEEN  1.1
**        NON-EXISTENT (PAGE/SEGMENT FAULT), AND KEY/FETCH          1.1
**        PROTECTION ERROR.                                         1.1
**      - TRANSLATE THE OUTPUT CHARACTER STRINGS FOR CONTROL BLOCK  1.1
**        FORMATTING. THANKS TO MR. S. GOLOB OF NEWSWEEK            1.1
**      - COMBINE XA AND SP MODULES INTO 1 VIA GLOBAL SYMBOL        1.1
**
**   VERSION 1.1A CHANGES (12/5/88):                               1.1A
**      - CORRECT HANDLING OF ERROR MESSAGES.                      1.1A
**
**   VERSION 1.1B CHANGES (10/31/89):                              1.1B
**      - Change amount of core gotten for ESA.                    1.1B
**
**   VERSION 1.1C CHANGES (11/28/90):                              1.1C
**      - Add changes from Bruce Bordonaro.                        1.1C
**            - Use STTMPMD.                                       1.1C
**            - Add significant number of macro formats.           1.1C
**      - Improve memory fetch when CPU does no data movement.     1.1C
**      - Fix problem in FRR recovery.                             1.1C
**
**   VERSION 1.1D CHANGES (01/22/91):                              1.1D
**      - Add spelling corrections from Sam Golob.                 1.1D
**      - Correct HELP screen for Overlay command.                 1.1D
**      - Correct Mode command.                                    1.1D
**      - Fix bugs in control block segments.                      1.1D
**      - Handle 31 bit address correctly when top bit on.         1.1D
**      - Correct title - Never did and never will actually        1.1D
**                         zap memory - use INCORZAP or #D         1.1D
**      - Stop long fields from overlaying next lines.             1.1D
**      - Correct blanking out of areas not available              1.1D
**      - Get memory line at a time in dump, if necessary.         1.1D
**
**   VERSION 1.1E CHANGES (07/02/91):                              1.1E
**      - If authorized then do memory fetches in KEY=0.           1.1E
**
**   CHANGES (04/21/17)       (Joe Reichman)                       JOE
**      - Endeavor to fix S0C4 occurrences when storage cannot
**        be obtained.  Changed SCHEDULE macro call to IEAMSCHD.
**        Moved FRR call into IEAMSCHD, etc.
**      - This version needs APF authorization. Message added.
**
**   CHANGES (02/06/19)       (Joe Reichman)                       Joe
**      - Allow LOOK to operate without getting common storage
**        in a user key.  VSM  ALLOWUSERKEYCSA(NO) in DIAGxx
**        PARMLIB member, needed to be set, to run LOOK.  Now it
**        doesn't matter.  VSM ALLOWUSERKEYCSA will be obsolete
**        after z/OS 2.4.  Also we now require APF authorization
**        for all invocations of LOOK, even in the current user's
**        address space, because CSA is now obtained in KEY 0.
**
**   CHANGES (02/12/19)       (Sam Golob)
**      - Cosmetic changes to the HELP screen (PF1) and to the
**        ASID title, from "DISPLAY ASID" to "CURRENT ASID" so
**        that you get the idea that the ASID number can be
**        changed by typing it over with another hex number.
**        Add more usage instructions at the beginning of the
**        program source.
**
**   CHANGES (02/25/19)       (Joe Reichman)                64 Bit Joe
**        Allow for 64-bit addressing.  Use G instead of J
**        to indicate that the contents at the address of the
**        given location will be regarded as an 8-byte address,
**        and not as a 4-byte address.  J still works to
**        indicate that the contents there will be regarded
**        as a 4-byte address.
**
**   CHANGES (04/03/19)    (Joe Reichman and Sam Golob)    (not marked)
**        This is a repaired version of the 64-bit LOOK.  It is
**        called LOOKN to distinguish it from the 31-bit versions.
**        Many bugs were fixed.  You can now type in an invalid
**        ASID and the program will re-display the former ASID,
**        with an appropriate error message.  Recovery for S0Cx
**        abends is much improved (all thanks to Joe).
**
*
         EJECT ,                                                   1.1D
         MACRO
&N       HEX   &TO,&FROM
&N       UNPK  TEMP1(9),&FROM.(5,R6)
         MVC   &TO.(8,R4),TEMP1
         TR    &TO.(8,R4),HEXTAB
         MEND
         EJECT ,                                                   1.1D
LOOK     CSECT
******************************                                     1.1D
**                                                                 1.1D
**     Fetch constant - maximum amount fetchable in one call       1.1D
**                                                                 1.1D
MAXFETCH EQU   4096                                                1.1D
**                                                                 1.1D
**                                                                 1.1D
******************************                                     1.1D
         SPACE 3                                                   1.1D
*                                                                   1.1
*        SET THE FOLLOWING GLOBAL SYMBOL TO 1 FOR XA AND 0 FOR SP   1.1
*                                                                   1.1
         GBLB  &XA                                                  1.1
&XA      SETB  1 =XA MODE              SET TO 1 FOR XA              1.1
         SPACE 3                                                    1.1
*  INITIALIZE THE PROGRAM
         SAVE  (14,12),,'LOOK..&SYSDATE..&SYSTIME'
         LR    R11,R15                 PERMANENT BASE
         USING LOOK,R11
         LA    R9,2048(,R11)           GET A SECOND BASE REG
         LA    R9,2048(,R9)
         USING LOOK+4096,R9
         USING LOOK+8192,R7
         LA    R7,2048(,R9)            Need another base 64 bit   Joe
         LA    R7,2048(,R7)            Need another base 64 bit   Joe
         AIF   (&XA).XA1                                            1.1
         GETMAIN R,LV=WORKLEN,SP=1                          SP      1.1
         AGO   .NXA1                                                1.1
.XA1     ANOP                                                       1.1
LOOK     AMODE 31                                           XA      1.1
LOOK     RMODE ANY                                          XA      1.1
         GETMAIN R,LV=WORKLEN,SP=1,LOC=(BELOW,ANY)          XA      1.1
.NXA1    ANOP                                                       1.1
         LR    R10,R1
         LR    R2,R10                  WORK AREA START
         L     R3,=A(WORKLEN)          LENGTH TO CLEAR
         SR    R5,R5                   ZERO PAD BYTE, LENGTH 2
         MVCL  R2,R4                   CLEAR THE WORK AREA
         USING WORKAREA,R10
         LA    R4,QDINIT
         LA    R3,QDISPLN              GET LENGTH
         LA    R2,QDISPLAY             POINT AT START
         LR    R5,R3                   SET FROM LENGTH
         MVCL  R2,R4                   INIT DISPLAY
         STG   R13,SAVE+8              CHAIN THE SAVE AREAS  64 Bit Joe
         LA    R15,SAVE
         STG   R15,16(,R13)                                  64 BIT Joe
         LR    R13,R15                 NEW SAVE AREA
         STM   R9,R11,BASE1        SAVE FIRST THREE REGS FOR AREA
         ST    R13,BASR13          AND ORIGINAL R13
         TESTAUTH FCTN=1               ARE WE AUTHORIZED
         LTR   R15,R15
         BNZ   ENDIT0                  IF NOT SEND MESSAGE
         LA    R1,50*HISTLEN           GET LENGTH OF HIST TBL
         GETMAIN R,SP=2,LV=(1)
         ST    R1,HISTORY              SAVE ADDRESS
         STFSMODE ON,INITIAL=YES       TELL TSO WE ARE FULLSCREEN
         STTMPMD ON,KEYS=ALL                                       1.1C
*
*        SET SUPERVISOR MODE IF AUTHORIZED
*
*        OI    FLAGS,NOAUTH            SET NOT AUTHORIZED           Joe
         L     R1,=A(WORKLN)           GET LENGTH OF CAS BUFFER
         ST    R1,CSALEN               SET LENGTH AND SP0
         MVI   CSALEN,241              SET CSA SP
*        NI    FLAGS,255-NOAUTH        MARK AUTHORIZED              Joe
         MODESET MODE=SUP              SET TO SUP MODE
         SPKA  0                       MAKE SURE GETMAIN IS KEY 0   Joe
NOTAUTH  DS    0H
         MVC   ASIDLN,ASIDFMT          SET MESSAGE
         L     R1,16                   GET CVT
         L     R2,0(,R1)               GET TCBWORDS
         L     R1,12(,R2)              GET OLD ASCB ADDR (MINE)
         USING ASCB,R1
         MVC   MYASID,ASCBASID         MOVE IN MY ASID
         MVC   CURASID,MYASID
         DROP  R1
         XC    CSAASID,CSAASID         CLEAR THE CSA BUFFER INDIC
         XC    CSASTAR,CSASTAR
         XC    CSAEND,CSAEND
         L     R0,CSALEN               GET LENGTH AND SP FOR CSA BUFFER
         GETMAIN R,LV=(0)
         ST    R1,CSAWORK              SAVE ADDR OF CSA BUFFER
         LR    R8,R1                   SET PROPER POINTER
         USING WORK,R8
*
*        SETUP ESTAE IN CORRECT MODE
*
         MVC   RETRY,=F'0'
         ESTAE RECOVERY,PARAM=(R8),MF=(E,ESTAE)
*
*        INITIALIZE ASID POINTERS
*
         LR    R0,R2                   Hold R2                    JOE
         XR    R2,R2                   Clear R2                   JOE
         IPK                                                      JOE
         ST    R2,USERSTOR             Sav                        JOE
         LR    R2,R0                                              JOE
         MVC   MYTCB,4(R2)             SAVE ADDR OF MY TCB
         MVC   MYASCB,12(R2)           SAVE ADDR OF MY ASCB
         LA    R1,BUF                  POINT TO TRUE BUFFER
         ST    R1,CSABUF
         LA    R0,SRBCCD               POINT TO CSA SRB CODE AREA
         LA    R1,SRBCODE              AND LENGTH OF CODE
         LR    R3,R1
         LA    R2,D#SRBCD              POINT TO CSECT CODE
         MVCL  R0,R2                   MOVE SRB CODE TO CSA
         B     ISCAN1                  GO AND PROCESS
         DROP  R8
         EJECT
***********************************************************************
*
*   INPUT SCAN
*
***********************************************************************
         SPACE 2
ISCAN    DS    0H
         OC    ASIDLN1,=CL4' '         UPPERCASE BEFORE COMPARISON
         CLC   SAVEASID,ASIDLN1        DID USER CHANGE ASID
         BE    ISCAN1                  NOPE
*
*        FORMAT AND SAVE USER ASID.
*
*=====>    Validate chars typed into ASID field  -  below
*        In this section of code, R15 thru R1 are work registers.
*
*        VERIFY IF WE TYPED IN NON-HEX CHARACTERS IN ASID FIELD
*
         STM   R15,R1,SAVE1501         SAVE REGISTERS AS WORK REGS
         L     R15,=A(TRVALHEX)        ACCESS THE TRANSLATE TABLE
         USING TRVALHEX,R15            TELL ASSEMBLER
         TR    ASIDLN1,TRVALTAB        NON-HEX CHARS BECOME X'CC'
         LA    R0,4                    SET UP LOOP TO DETECT THEM
         LA    R1,ASIDLN1              POINT TO TRANSLATED ASID INPUT
ASIDVERL DS    0H                      LOOP TO LOOK FOR NON-HEX CHARS
         CLI   0(R1),X'CC'             IS IT INVALID?
         BE    ASIDBCH                 YES. REPORT THAT.
         LA    R1,1(,R1)               TRY NEXT CHARACTER
         BCT   R0,ASIDVERL             LOOP 4 TIMES
         B     ASIDGUDC                GO TELL THAT GOOD ASID CHARS
ASIDGUDC DS    0H                      NO INVALID CHARS TYPED IN
         DROP  R15
*=====>    Validate chars typed into ASID field  -  above
*                                      CONVERT DISPLAY ASID TO HEX HWD
         MVC   TEMP1(4),ASIDLN1        GET ASID TYPED BY USER
*                                      ALREADY UPPERCASED VIA TR TABLE
         TR    TEMP1(4),HEXTAB         MAKE PACKABLE
         PACK  TEMP2(3),TEMP1(5)
         MVC   CURASID,TEMP2           GET NEW ASID AS A HALFWORD NMBER
*====>     Validate if number typed in, is a valid ASID - below
ASIDVAL  DS    0H                      Now check for invalid ASID nmbrs
         L     R15,CVTPTR              R15 -> cvt
         L     R15,CVTASVT-CVT(,R15)   R15 -> asvt
         USING ASVT,R15
         XR    R0,R0                   Clear work register
         LH    R0,CURASID              Load ASID
         C     R0,ASVTMAXU             Higher than Max defined?
         BH    ASIDBCH                 Yes. Show error.
         LA    R1,ASVTENTY-ASVT(,R15)  Get first ASVT slot
         BCTR  R0,0                    Down By 1 (starts with 0)
         SLL   R0,2                    Multiply by 4
         AR    R1,R0                   Point to ASCB addr in ASVT
         TM    0(R1),X'80'             Is it Available?
         BO    ASIDINAC                No. Show it is inactive.
ASIDVALE DS    0H
         LM    R15,R1,SAVE1501         RESTORE R15 THRU R1
         B     ISCAN1
         DROP  R15
*====>     Validate if number typed in, is a valid ASID - above
*
*--->  ASID typed entry errors - below
ASIDBCH  DS    0H                      REPORT NON-HEX CHARS TYPED IN
         MVC   MSGLINE,INVASIDC        INVALID CHARS TYPED IN ASID
         MVC   ASIDLN1,SAVEASID        PLUG IN PREVIOUS ASID VALUE
         MVC   CURASID,MYASID          GUARANTEE GOOD ASID (MYASID)
         B     TPUTSCRN                AND RE-DISPLAY THE SCREEN
*
ASIDINAC DS    0H                      REPORT INACTIVE ASID TYPED IN
         MVC   MSGLINE,INVTYPDV        INVALID CHARS TYPED IN ASID
         MVC   ASIDLN1,SAVEASID        PLUG IN PREVIOUS ASID VALUE
         MVC   CURASID,MYASID          GUARANTEE GOOD ASID (MYASID)
         B     TPUTSCRN                AND RE-DISPLAY THE SCREEN
*--->  ASID typed entry errors - above
*
ISCAN1   MVC   INPSAVE,INPLINE         SAVE LAST USER INPUT
ISCAN2   LA    R3,INPLINE              POINT TO START OF INPUT
         LA    R1,SCANTAB              COMMAND TABLE
         NI    FLAGS,255-INDFLAG-IND31-IND64 TURN OFF INDIRECT FLAGS
         MVC   MSGLINE,TITLE           CLEAR OUT ERROR MSG
SCANLOOP L     R2,4(,R1)               GET TABLE ENTRY
         CLC   0(1,R1),ENDTAB          SEE IF END OF TABLE
         BE    NUMSCAN                 IF YES, ASSUME NUMERIC INPUT
         CLC   0(1,R1),INPLINE         SEE IF COMMAND FOUND
         BER   R2                      IF YES, GO TO COMM ROUINE
         LA    R1,8(,R1)               NEXT ENTRY ADDRESS
         B     SCANLOOP
SAVE1501 DS    3F
SCANTAB  DS    0F                      COMMAND TABLE
         DC    CL4' ',A(FORMAT)
         DC    CL4'I',A(INDIR)
         DC    CL4'J',A(INDIR31)
         DC    CL4'G',A(INDIR64)
         DC    CL4'>',A(FWD)
         DC    CL4'<',A(BACK)
         DC    CL4'=',A(DEFINE)
         DC    CL4',',A(NUMSCAN)
         DC    CL4'M',A(MODE)
         DC    CL4'L',A(LINK)
         DC    CL4'O',A(OVERLAY)
         DC    CL4'R',A(REFRESH)
ENDTAB   DC    X'FF'                   END OF TABLE INDICATOR
         SPACE 2
***********************************************************************
*
*     FORMAT THE OUTPUT SCREEN
*
***********************************************************************
         SPACE 2
FORMAT   LA    R3,INPLINE              CURSOR ADDRESS
         MVC   INPLINE,BLANKS          CLEAR INPUT LINE
FORMAT2  BAL   R14,ERASE               CLEAR THE SCREEN
         LLGH  R2,CURRENT              HISTORY TABLE POINTE64 Bit Joe
         A     R2,HISTORY              POINT AT HISTORY TABLE ENTRY
         USING HIST,R2                 IDENTIFY HISTORY ENTRY FORMAT
         LG    R4,HISTADDR             GET ADDRESS TO DISP 64 BIT Joe
         TM    HISTCBHP,X'80'          IS THIS A CB MAP IN USE
         BO    CBHIT                   IF SO THE PROCESS IT
         CLC   =X'7FFFFFFF',HISTCBHP   SUPPRESSED CB USAGE
         BE    NOCB
         DROP  R2
         SPACE 2
*----------------------------------------------------------------------
*
*        SEE IF CONTROL BLOCK MAP EXISTS
*
*----------------------------------------------------------------------
         SPACE 2
DUMP     L     R5,=V(CBMACS)           GET START OF INDEX
         LTR   R5,R5                   ANY VALUE
         BZ    NOCB                    NOPE
         USING CBH,R5                  ADDRESS THE CONTROL BLK HEADER
DUMPCB   CLC   =F'0',CBHNEXT           SEE IF END OF INDEX
         BE    NOCB                    IF YES, NO CB FOUND
         LLGT  R2,CBHVOFF              GET CB IDENTIFIER OFFSET
         AGR   R2,R4                   ADD DISPLAY ADDRESS
         SR    R3,R3                   CLEAR A REGISTER FOR IC
         IC    R3,CBHVLEN              GET LENGTH
         LR    R0,R3                   PUT IN 0 FOR GETSTOR
         LA    R1,DUMPDATA             TARGET ADDR
         BAL   R14,GETSTOR             FETCH THE DATA
         B     NOTCB                   BR IF NO DATA FOUND
         B     NOTCB                   BR IF PARTIAL DATA FOUND
         BCTR  R3,0                    GET MACHINE LENGTH
         EX    R3,CBFNDIT              LOOK FOR VALIDATION FIELD
         BE    CBHIT                   BR IF YES, CB WAS FOUND
NOTCB    L     R5,CBHNEXT              NEXT INDEX ENTRY
         MVC   MSGLINE,BLANKS          Clear useless error msg     1.1C
         B     DUMPCB                  AND CHECK FOR MORE CB'S
CBFNDIT  CLC   CBHVAL(*-*),DUMPDATA    SEE IF IDENTIFIER MATCH
         DROP  R5
         SPACE 2
*----------------------------------------------------------------------
*
* IF NO CONTROL BLOCK TO BE SHOWN, JUST USE DUMP FORMAT
*
*----------------------------------------------------------------------
         SPACE 2
NOCB     DS    0H
*        DBGRDIE LINKAGE=SVC
         LGR   R2,R4                   COPY ADDR TO DISPLAY 64 Bit Joe
         TM    MODEFLAG,ALIGN          QUADWORD ALIGNMENT WANTED
         BZ    DUMPNOA                 BR IF NOT
         NG    R2,=XL8'FFFFFFFFFFFFFFF0'   ROUND DOWN For   64 bit Joe
DUMPNOA  TM    MODEFLAG,MIDDUMP        PUT ADDR INCENTER OF SCREEN?
         BZ    DUMPNOM                 BR IF NOT
         SH    R2,=H'128'              IF YES, BACK UP QUAD WORDS
* R2 NOW HAS FIRST ADDRESS TO DISPLAY
DUMPNOM  LA    R0,256                  LENGTH TO FETCH
         LA    R1,DUMPDATA             TARGET ADDRESS
         STG   R2,TEMP3                Store 64 bit value 64 bit Joe
         L     R2,TEMP3                64 bit address
         C     R2,=F'0'                Is it 64 bit       64 bit Joe
         BZ    ITS_31                                     64 Bit Joe
         LG    R2,TEMP3                64 bit address     64 bIT Joe
         B     GET_STOR
ITS_31   DS    0H                                         64 BIT Joe
         LG    R2,TEMP3                64 bit address     64 bIT Joe
         LA    R2,0(0,R2)              clear top bit               1.1D
GET_STOR DS    0H
         BAL   R14,GETSTOR             GO FETCH THE DATA
         B     DUMPLN                  go dump by line             1.1D
         NOP   0                       RETURN IF PARTIAL DATA FOUND
         LA    R6,DUMPDATA             POINT TO DATA TO DISPLAY
         LA    R4,OUT1                 FIRST OUTPUT LINE ADDR
         LA    R5,16                   NO. OF LINES TO DISPLAY
DUMPLOOP DS    0H                      FORMAT THE DISPLAY
         STCM  R2,15,TEMP2             ADDRESS TO SHOW
         UNPK  TEMP1(9),TEMP2(5)       CONVERT BINARY TO HEX
         MVC   9(8,R4),TEMP1           LOW ORDER 32 BITS
         TR    9(8,R4),HEXTAB
         STG   R2,TEMP3                Store 64 bit value 64 bit Joe
         L     R2,TEMP3                64 bit address
         LTR   R2,R2                   64 bit value       64 bit Joe
         BZ    ITS31
         STCMH R2,15,TEMP2             Store High Order   64 bit Joe
         UNPK  TEMP1(9),TEMP2(5)       CONVERT BINARY TO H64 Bit Joe
         MVC   0(8,R4),TEMP1           LOW ORDER 32 BITS  64 Bit Joe
         TR    0(8,R4),HEXTAB                             64 bit Joe
         B     SET64                                      64 Bit Joe
ITS31    DS    0H                                         64 bit Joe
         MVC   0(8,R4),=C'00000000'    DUMMY FOR HI ORDER ADDRESS
SET64    DS    0H                                         64 bit Joe
         LG    R2,TEMP3                Reset R2           64 bit Joe
         MVI   8(R4),C'_'              SEPARATE FROM HI ORDER 32 BITS
         HEX   21,0                    CONVERT FIRST WORD TO HEX
         HEX   31,4                    SECOND WORD TO HEX
         HEX   41,8                    THIRD WORD
         HEX   51,12                   FOURTH AND LAST WORD TO HEX
         MVI   61(R4),C'*'             FRAME THE EBCDIC DISPLAY
         MVI   78(R4),C'*'             FRAME THE OTHER SIDE
         MVC   62(16,R4),0(R6)         COPY THE EBCDIC DATA
         TR    62(16,R4),VALCHAR       DELETE INVALID CHARS
         AH    R2,=H'16'               BUMP UP LINE       64 BIT jOE
         LA    R6,16(,R6)              NEXT DATA AREA
         LA    R4,80(,R4)              NEXT OUTPUT LINE
         BCT   R5,DUMPLOOP             GO DO NEXT LINE
         B     BLANKSC                 Try to blank out data not   1.1D
         SPACE 2                                                   1.1D
DUMPLN   DS    0H                      Fetch and dump each line    1.1D
         LA    R4,OUT1                 FIRST OUTPUT LINE ADDR      1.1D
         LA    R5,16                   NO. OF LINES TO DISPLAY     1.1D
DUMPLP2  DS    0H                      FORMAT THE DISPLAY          1.1D
         STCM  R2,15,TEMP2             ADDRESS TO SHOW             1.1D
         UNPK  TEMP1(9),TEMP2(5)       CONVERT BINARY TO HEX       1.1D
         MVC   0(8,R4),TEMP1                                       1.1D
         TR    0(8,R4),HEXTAB                                      1.1D
         LA    R0,16                   length of a line            1.1D
         LA    R1,DUMPDATA             where to put data           1.1D
         BAL   R14,GETSTOR             get it                      1.1D
         B     DLKILL                  +0 no data found            1.1D
         NOP   0                       +4 partial data found       1.1D
         LA    R6,DUMPDATA             +8 all data found           1.1D
         HEX   21,0                    CONVERT FIRST WORD TO HEX   1.1D
         HEX   31,4                    SECOND WORD TO HEX          1.1D
         HEX   41,8                    THIRD WORD                  1.1D
         HEX   51,12                   FOURTH AND LAST WORD TO HEX 1.1D
         MVI   61(R4),C'*'             FRAME THE EBCDIC DISPLAY    1.1D
         MVI   78(R4),C'*'             FRAME THE OTHER SIDE        1.1D
         MVC   62(16,R4),0(R6)         COPY THE EBCDIC DATA        1.1D
         TR    62(16,R4),VALCHAR       DELETE INVALID CHARS        1.1D
DLKILL   DS    0H                                                  1.1D
         LA    R2,16(,R2)              NEXT LINE ADDR              1.1D
*        LA    R6,16(,R6)              NEXT DATA AREA              1.1D
         LA    R4,80(,R4)              NEXT OUTPUT LINE            1.1D
         BCT   R5,DUMPLP2              GO DO NEXT LINE             1.1D
BLANKSC  DS    0H                                                  1.1D
         SPACE 2
*----------------------------------------------------------------------
*
* NOW BLANK OUT THE SCREEN WHERE THE PAGE DIDN'T EXIST
*
*----------------------------------------------------------------------
         SPACE 2
         LA    R4,OUT1                 POINT TO FIRST OUTPUT LINE
         SH    R2,=H'256'              FIRST ADDRESS DISPLAYED
         LA    R5,16                   NUMBER OF LINES DISPLAYED
BLLOOP   LA    R15,15(,R2)             LAST ADDRESS ON CURRENT LINE
         CLC   LOGOOD,HIGOOD           ARE WE IN A WRAP CONDITION
         BH    BLLP0                   YES SO SKIP NOLINE CHECK
         CG    R2,HIGOOD               IF START>=HIGH    64 BIT     Joe
         BNL   NOLINE                     THEN BLANK ENTIRE LINE
BLLP0    C     R2,LOGOOD               IF START<LOW & END>=LOW
         BNL   BLLP1                      THEN HI GOOD AND LOW NEEDS
*                                                  BLANK
         C     R15,LOGOOD
         BNL   HIMIX
BLLP1    CG    R2,HIGOOD               IF START<HIGH & END>HI64 BIT Joe
         BNL   BLLP2                      THEN LOW GOOD AND BLANK
*                                                HIGH
         CG    R15,HIGOOD                                    64 bit Joe
         BH    LOWOK
BLLP2    DS    0H                      LINE OK OTHERWISE
         B     BLOOPEND
* BOTH LOW AND HIGH MISSING -- BLANK ENTIRE LINE
NOLINE   DS    0H                                           64 BIT JOE
*OLINE   MVI   12(R4),C' '             START OF DATA        64 BIT JOE
*        MVC   13(57,R4),12(R4)        CLEAR THE LINE       64 BIT JOE
         B     BLOOPEND                GO CHECK ANOTHER LINE
* BR HERE IF LOW END GOOD, HIGH MAY BE  MISSING
LOWOK    SG    R15,HIGOOD              # OF BYTES TO BLANK   64 BIT Joe
* THE FOLLOWING CODE TAKES CARE OF LOW STORAGE WRAP
         CH    R15,=H'15'              MORE THAN 15 BYTES TO CLEAR
         BH    BLOOPEND                IF YES, IT WRAPPED, NO CLEAR
         LR    R1,R15                  COPY # TO BLANK
         SRL   R1,2                    FIND # OF WORDS
         SLL   R1,1                    TWO BLANKS PER WORD
         AR    R1,R15                  ADD NUMBER OF HEX CHARS
         AR    R1,R15                  WHICH IS TWICE THE # OF BYTES
         LA    R6,50(,R4)              POINT JUST AFTER HEX DATA
         SR    R6,R1                   FIRST BYTE TO CLEAR
         BCTR  R1,0                    REDUCE BY 1 FOR EXEXUTE
         EX    R1,CLEARMVC             CLEAR HEX SIDE
         LA    R6,69(,R4)              POINT TO TRAILING *
         SR    R6,R15
         EX    R15,CLEARMVC            CLEAR EBCDIC AND *
         MVI   0(R6),C'*'              NOTE END OF EBCDIC DATA
         B     BLOOPEND                GO CHECK NEXT LINE
* COME HERE WHEN HI END GOOD AND LOW END MISSING
HIMIX    L     R15,LOGOOD              LOWEST GOOD ADDR
         SR    R15,R2                  NUMBER OF BYTES TO CLEAR
         CH    R15,=H'16'              Total line                  1.1D
         BNL   NOLINE                  Kill complete line          1.1D
         LR    R1,R15                  COPY # TO CLEAR
         SRL   R1,2                    # OF WORDS TO CLEAR
         SLL   R1,1                    NUMBER OF IMBEDDED BLANKS
         AR    R1,R15                  ADD # OF HEX CHARS
         AR    R1,R15
         BCTR  R1,0                    REDUCE BY 1 FOR MVC
         LA    R6,12(,R4)              START OF HEX DATA
         EX    R1,CLEARMVC             AND CLEAR THE HEX DATA
         LA    R6,52(,R4)              POINT TO FIRST * ON LINE
         EX    R15,CLEARMVC            CLEAR * AND EBCDIC DATA
         LA    R6,52(R15,R4)           POINT TO FIRST CLEARED BYTE 1.1D
         MVI   0(R6),C'*'              AND DROP IN A *
BLOOPEND LA    R4,80(,R4)              POINT TO NEXT LINE
         LA    R2,16(,R2)              ADDRESS ON NEXT LINE
         BCT   R5,BLLOOP               AND SCAN ALL LINES
         SPACE 2
*----------------------------------------------------------------------
*
*  PUT IN ARROWS TO POINT TO DESIRED DATA
*
*----------------------------------------------------------------------
         SPACE 2
         LA    R4,OUT1                 ADDR OF FIRST LINE
         TM    MODEFLAG,MIDDUMP        DOES IT BELONG IN THE MIDDLE
         BZ    ARRTOP                  BR IF NOT
         LA    R4,OUT9                 POINT TO MIDDLE LINE
ARRTOP   SR    R1,R1                   ASSUME NO QUADWORD ALIGNMENT
         TM    MODEFLAG,ALIGN          WAS ASSUMPTION CORRECT
         BZ    ARRALIGN                BR IF YES, ELSE GET OFFSET
         LA    R1,15                   MASK FOR LOW 4 BITS
         NR    R1,R2                   GET BYTE OFFSET FOR ARROW
* FIRST DO THE EBCDIC SIDE
ARRALIGN LA    R15,60(,R4)             BYTE BEFORE FIRST *
         EX    R1,MOVEMVC              MOVE THE DATA BACK
         AR    R15,R1                  ADDR OF LAST BYTE MOVED
         MVI   1(R15),C'>'             PUT IN THE ARROW
* NOW MOVE THE HEX SIDE
         SR    R0,R0                   CLEAR HIGH ORDER BITS
         SLDL  R0,30                   WHICH WORD IS TO BE MOVED
         SRL   R1,30                   NUMBER OF BYTES TO BE MOVED
         LR    R15,R0                  COPY OFFSET OF WORD TO MOVE
         MH    R15,=H'10'              EACH WORD TAKES UP 10 BYTES
         LA    R15,19(R4,R15)          POINT IN FRONT OF WORD TO MOVE
         SLL   R1,R1                   NUMBER OF HEX DIGITS TO MOVE
         EX    R1,MOVEMVC              MOVE THE DATA BACK
         AR    R15,R1                  POINT TO PLACE FOR ARROW
         MVI   1(R15),C'>'             AND PUT IT THERE
* FALL  THRU TO SHOW THE SCREEN
         EJECT
*
* DISPLAY THE PAGE AND CHECK FOR END REQUEST
*
DISPLAY  UNPK  TEMP1(5),CURASID(3)     FORMAT CURRENT ASID
         MVC   ASIDLN1(4),TEMP1        AND PUT ON SCREEN
         TR    ASIDLN1(4),HEXTAB
         MVC   SAVEASID,ASIDLN1        SAVE FORMATTED VERSION
         MVC   KEYS,KEY1               SETUP PFK
         MVC   KEYS+80,KEY2                 INFO LINE
*
TPUTSCRN DS    0H
*        XGR   R4,R4                  Clear out data ptr 31 or 64 Joe
         LA    R0,QDSLNG
         TPUT  QDSCREEN,(0),FULLSCR MF=(E,QTPUT)
         XC    INPLINE,INPLINE
         XC    PFREPLY,PFREPLY
         TGET  PFREPLY,69,ASIS MF=(E,QTGET)
         LR    R3,R1                   SAVE INPUT LENGTH
         CH    R15,=H'12'     IS INPUT LONGER THAN BUFFER?
         BNE   NOCLEAR        NO. CONTINUE.
         TCLEARQ INPUT        CLEAR THE QUEUE
NOCLEAR  DS    0H
*        MVC   MSGLINE,BLANKS          INDICATE NO ERROR           1.1A
         LA    R1,PFREPLY+3            POINT AT FIRST BYTE
         SH    R3,=H'3'                ADJUST LENGTH
*
**       HANDLE ASID IF NECESSARY
*
         CLC   0(3,R1),=X'1140F9'      IS THIS ASID MODIFICATION
         BNE   NOASID                  NO SO SKIP
         LA    R1,3(,R1)               POINT AT FIRST BYTE
         SH    R3,=H'3'                ADJUST LENGTH
         LR    R2,R1                   SAVE START ADDRESS
ASIDLOOP CLI   0(R1),X'11'             LOOK FOR START FIELD
         BE    HAVEASID
         LA    R1,1(,R1)               BUMP POINTER
         BCT   R3,ASIDLOOP
HAVEASID LR    R15,R1                  MOVE POINTER
         SR    R15,R2                  GET LENGTH
         BZ    NOASID
         MVC   ASIDLN1,=CL4' '
         LA    R4,ASIDLN1+4            GET TO ADDRESS +4
         SR    R4,R15                      - REAL LENGTH
         BCTR  R15,0                   GET MACHINE LENGTH
         EX    R15,MOVERPLY
NOASID   DS    0H
         LTR   R3,R3                   ANY DATA LEFT
         BZ    ENDINP
         CLC   0(3,R1),=X'11C15C'      CHECK FOR START OF FIELD
         BNE   ENDINP                  IF NOT HERE THEN SKIP
         LA    R1,3(,R1)               POINT AT FIRST BYTE
         SH    R3,=H'3'                ADJUST LENGTH
         LR    R2,R1                   SAVE START ADDRESS
RPLYLOOP CLI   0(R1),X'11'             LOOK FOR START FIELD
         BE    HAVERPLY
         LA    R1,1(,R1)               BUMP POINTER
         BCT   R3,RPLYLOOP
HAVERPLY LR    R15,R1                  MOVE POINTER
         SR    R15,R2                  GET LENGTH
         BZ    NOASID
         LA    R4,INPLINE              GET TO ADDRESS
         BCTR  R15,0                   GET MACHINE LENGTH
         EX    R15,MOVERPLY
ENDINP   OC    INPLINE,=CL63' '        MAKE UPPERCASE
         SPACE 2
         IC    R4,PFCODE
         XR    R5,R5
         CLI   PFCODE,X'7D'      ENTER?
         BE    ENTER             /YES - TREAT AS ENTER
         CLI   PFCODE,X'F0'      TEST-REQ/SYS-REQ?
         BE    ENTER             /YES - TREAT AS ENTER
         CLI   PFCODE,X'01'      OTHER KIND OF SYS-REQ?
         BE    ENTER             /YES - TREAT AS ENTER
         CLI   PFCODE,X'6C'      PA1?
         BE    ENDIT             /YES - TERMINATE
         CLI   PFCODE,X'6E'      PA2?
         BE    TPUTSCRN          /YES - GO RESHOW SCREEN
         CLI   PFCODE,X'6B'      PA3?  (TCAM GENERATED)
         BE    TPUTSCRN          /YES - GO RESHOW SCREEN
         N     R4,=X'0000000F'   EXTRACT PF-KEY NUMBER
         CH    R4,=H'12'
         BH    ENTER            "ENTER" KEY
         BCTR  R4,0
         SLL   R4,2              TIMES SIZE OF AN ENTRY
         B     PFKEYTAB(R4)
PFKEYTAB B     HELP                    PF1
         B     DISPLAY                 PF2
         B     ENDIT                   PF3    QUIT
         B     DISPLAY                 PF4
         B     REPEAT                  PF5    REPEAT COMMAND
         B     DISPLAY                 PF6
         B     UP                      PF7    SCROLL UP
         B     DOWN                    PF8    SCROLL DOWN
         B     BACK                    PF9    SCROLL BACKWARDS
         B     FWD                     PF10   SCROLL FORWARDS
         B     DISPLAY                 PF11
         B     DISPLAY                 PF12
MOVERPLY MVC   0(0,R4),0(R2)           **EXECUTED**
         EJECT
ENTER    CLC   =C'END',INPLINE         SEE IF END TYPED
         BNE   ISCAN                   IF NOT, GO LOOK AT INPUT
* CLEAN UP AND GO AWAY
ENDIT    DS    0H
         LM    R0,R1,CSALEN            GET SP, LEN, AND ADDR
         LTR   R1,R1                   WAS BUFFER GOTTEN
         BZ    ENDIT1                  NOPE
         FREEMAIN R,LV=(0),A=(1)       FREE BUFFER
ENDIT1   DS    0H                      NOT AUTH HANDLING
*        TM    FLAGS,NOAUTH            ARE WE AUTHORIZED            Joe
*        BO    ENDIT2                  NOPE                         Joe
         MODESET MODE=PROB             RESET MODE
ENDIT2   DS    0H
         STTMPMD OFF                                               1.1C
         STFSMODE OFF                  RESET FULLSCREEN
         LG    R13,SAVE+8              GET ORIGINAL SAVE AR 64 Bit Joe
         FREEMAIN R,LV=WORKLEN,SP=1,A=(R10)
         RETURN (14,12),RC=0
* ----------------------------------------------------------------- *
ENDIT0   DS    0H
         MVC   OUTAREA(80),NOTAUTHM
         STM   R14,R1,SAVE14T1
         TPUT  OUTAREA,80
         LM    R14,R1,SAVE14T1
         B     ENDIT2
NOTAUTHM DC CL80'***** THIS PROGRAM MUST BE RUN APF AUTHORIZED *****'
         EJECT
*----------------------------------------------------------------------
*
* CBHIT  -- CONTROL BLOCK FORMATTING ROUTINE
* AT ENTRY:
*              R4 HAS ADDRESS TO DISPLAY (OFFSET 0 - MAIN SEGMENT)
*              R5 HAS CONTROL BLOCK HEADER ADDRESS
*
*----------------------------------------------------------------------
         SPACE 2
CBHIT    LH    R2,CURRENT              GET HISTORY TABLE POINTER
         A     R2,HISTORY              GET ENTRY ADDRESS
         USING HIST,R2                 SETUP FORMAT OF ENTRY
         ICM   R6,15,HISTCBSP          LAST SEGMENT DISPLAYED
         BNZ   CBHIT2                  BR IF A CONTINUING DISPLAY
         USING CBH,R5                  ADDRESS HEADER BLOCK
         L     R6,CBHCBSP              ELSE GET FIRST SEG ADDRESS
         ST    R6,HISTCBSP             AND SAVE FOR LATER
         ST    R5,HISTCBHP             AND SAVE FOR LATER
         OI    HISTCBHP,X'80'          NOTE CB FORMAT ROUTINE IN USE
*   GET BLOCK NAME AND HANDLE ANY SEGMENT INDIRECTION
CBHIT2   DS    0H
         USING CBS,R6
         L     R5,HISTCBHP             POINT TO CB HEADER
         MVC   MSGLINE+36(8),CBHNAME   MOVE IN CB NAME
         STG   R4,TEMP2             SAVE ADDRESS OF BLOCK    64 Bit Joe
         CLC   TEMP2(4),=4X'00'     31 Bit Address           64 bit Joe
         BE    MAKE31               YES; Forgot top half
         UNPK  TEMP1(9),TEMP2(5)          AND CONVERT
         TR    TEMP1(8),HEXTAB               TO HEX
         MVC   MSGLINE+18(8),TEMP1     MOVE IN ADDRESS OF BLOCK
MAKE31   DS    0H                                            64 Bit Joe
         UNPK  TEMP1(9),TEMP2+4(5)        AND CONVERT        64 bit Joe
         TR    TEMP1(8),HEXTAB               TO HEX          64 bit Joe
         MVC   MSGLINE+26(8),TEMP1     MOVE IN ADDRESS OF BL 64 bit Joe
         DROP  R2,R5
         CLC   =H'0',CBSILEN           IS THIS SEGMENT INDIRECT
         BE    CBHIT3                  IF NOT THEN SKIP CODE
         LH    R0,CBSILEN              GET LENGTH TO FETCH (ALWAYS 4
         LA    R1,DUMPDATA             WHERE TO PUT IT
         LH    R2,CBSIOFF              GET INDIRECT OFFSET
         AR    R2,R4                   GET TRUE MAIN BLOCK ADDRESS
         BAL   R14,GETSTOR             GET THE INDIRECT WORD
         B     NOCB                    BR IF NO DATA FETCHED
         B     NOCB                    BR IF PARTIAL DATA FETCHED
         L     R4,DUMPDATA             RESET THE ADDR TO DUMD
         LH    R2,CURRENT
         A     R2,HISTORY              GET ADDR OF ENTRY
         ST    R4,HISTSADR-HIST(R2)    SAVE SEGMENT ADDRESS
CBHIT3   DS    0H
         LH    R0,CBSDLEN              LENGTH TO FETCH
         LA    R1,DUMPDATA             TARGET ADDRESS
         LH    R2,CBSDOFF              OFFSET TO FETCH
         AR    R2,R4                   ADD START OF CB ADDRESS
         BAL   R14,GETSTOR             GO FETCH THE DATA
         B     NOCB                    BR IF NO DATA FETCHED
         B     NOCB                    BR IF PARTIAL DATA FETCHED
         LA    R5,OUT1-80              START OF SCREEN
         LA    R2,DUMPDATA             POINT TO DATA BUFFER
         SH    R2,CBSDOFF              BACKUP TO VIRTUAL CB ORIGIN
         LA    R6,CBSLEN(,R6)          POINT AT FIRST CB FIELD
         USING CBF,R6
CBLOOP   DS    0H
         LH    R1,CBFLINE              GET LINE NUMBER
         MH    R1,=H'80'               TIMES LINE LENGTH
         AH    R1,CBFCOLM              PLUS THE COLUMN NUMBER
         AR    R1,R5                   PLUS START OF LINE
         MVC   0(8,R1),CBFNAME         SET NAME FIELD
         LA    R1,8(,R1)               SKIP NAME
         LH    R14,CBFOFFS             GET OFFSET INTO CB
         AR    R14,R2                  GET ADDRESS IN FETCHED DATA
         SR    R15,R15                 CLEAR REGISTER
         IC    R15,CBFDLEN             GET LENGTH OF DATA ITEM
         LA    R0,80-8                 get max column less label   1.1D
         SH    R0,CBFCOLM              and starting col number     1.1D
*   FORMAT CHARACTER AS DISPLAY AND REST AS HEX
         CLI   CBFTYPE,C'C'            WHAT IS TYPE
         BNE   CBFLP1                  IF NOT CHAR THEN DO HEX     1.1D
         CR    R15,R0                  see if data too big         1.1D
         BNH   *+6                     use actual length           1.1D
         LR    R15,R0                  truncate data               1.1D
         BCTR  R15,0                   GET MACHINE LENGTH
         EX    R15,CBMVC               MOVE IN DATA
         EX    R15,CBTR                OUTPUT ONLY VALID CHARS      1.1
         B     CBFEND
CBFLP1   SRL   R0,1                    convert columns to bytes    1.1D
         CR    R15,R0                  see if data too big         1.1D
         BNH   *+6                     use actual length           1.1D
         LR    R15,R0                  truncate data               1.1D
CBFLOOP  MVC   TEMP2(1),0(R14)         MOVE IN DATA BYTE
         UNPK  TEMP1(3),TEMP2(2)
         TR    TEMP1(2),HEXTAB
         MVC   0(2,R1),TEMP1           MOVE IN CONVERTED BYTE
         LA    R1,2(,R1)               BUMP OUTPUT ADDRESS
         LA    R14,1(,R14)             BUMP INPUT ADDRESS
         BCT   R15,CBFLOOP             KEEP LOOPINT
CBFEND   LA    R6,CBFLEN(,R6)          BUMP TO NEW FIELD
         CLC   0(4,R6),=F'0'           END OF SEGMENT
         BNE   CBLOOP                  IF NOT THEN KEEP GOING
         B     DISPLAY                 ALL DONE SO DISPLAY IT
         DROP  R6
         SPACE 1
CBMVC    MVC   0(0,R1),0(R14)          **EXECUTED** MOVE IN DATA
CBTR     TR    0(0,R1),VALCHAR         **EXECUTED** MAKE VALID      1.1
         SPACE 2
*----------------------------------------------------------------------
*
*  GET ADDRESS OF CURRENT CONTROL BLOCK SEGMENT
*     ON EXIT R2 = ADDR OF THIS CONTROL BLOCK SEGMENT
*
*----------------------------------------------------------------------
GETCURAD DS    0H
         LH    R2,CURRENT              GET HIST TABLE OFFSET
         A     R2,HISTORY              GET ENTRY
         USING HIST,R2
         CLC   =F'0',HISTSADR          IS SEGMENT A SECONDARY SEGMENT
         BE    GCA1                    NOPE, SO SKIP CODE
         L     R2,HISTSADR             GET ADDRESS OF BLOCK
         BR    R14
GCA1     LG    R2,HISTADDR             GET MAIN BLOCK ADDR  64 Bit Joe
         BR    R14
         DROP  R2
         EJECT
***********************************************************************
*
* COMMAND ROUTINES
*
         SPACE 2
*----------------------------------------------------------------------
*
* HELP -- DISPLAY HELP INFORMATION
*
*----------------------------------------------------------------------
         SPACE 2
HELP     DS    0H
         LA    R1,16*80
         LR    R3,R1
         L     R2,=A(HELPMSG)      POINT AT FROM
         LA    R0,OUT1
         MVCL  R0,R2
         B     DISPLAY
         SPACE 2
*----------------------------------------------------------------------
*
* REFRESH -- REFETCH THE CORE AND REDISPLAY IT
*
*----------------------------------------------------------------------
         SPACE 2
REFRESH  OI    FLAGS,RFRSH             SET REFRESH FLAG
         B     FORMAT                  REFORMAT SCREEN
         SPACE 2
*----------------------------------------------------------------------
*
* OVERLAY  --  MANIPULATE CONTROL BLOCK FORMATTING
*
*----------------------------------------------------------------------
         SPACE 2
OVERLAY  CLC   =C'NULL',INPLINE+1      SEE IF NO FORMATTING WANTED
         BE    OVERNULL                BR IF YES
         L     R5,=V(CBMACS)           GET CB MAP INDEX
         LTR   R5,R5                   ANY MAPS
         BZ    OVERNULL                IF NOT TREAT AS NULL OVERLAY
         USING CBH,R5                  SETUP ADDRESSABILITY
OVERLOOP CLC   =F'0',CBHNEXT           END OF CONTROL BLOCKS
         BE    FORMAT                  IF YES, IGNORE COMMAND
         CLC   INPLINE+1(8),CBHNAME    SEE IF CB MATCH
         BE    OVERHIT                 BR IF YES
         L     R5,CBHNEXT              ELSE POINT TO NEXT ENTRY
         B     OVERLOOP                AND KEEP LOOKING
OVERHIT  L     R6,CBHCBSP              START SEG ADDR FOR CB FOUND
         LH    R2,CURRENT              CURRENT HIST TABLE ENTRY OFFSET
         A     R2,HISTORY              GET ENTRY ADDRESS
         USING HIST,R2                 SETUP ENTRY FORMAT
         ST    R5,HISTCBHP             POINT AT HEADER
         ST    R6,HISTCBSP             POINT AT SEGMENT(FIRST)
         OI    HISTCBHP,X'80'          MARK AS CB
         XC    HISTSADR,HISTSADR       CLEAR SEC SEG ADDR
         B     FORMAT                  GO SHOW IT
         SPACE 1
OVERNULL LH    R2,CURRENT              CURRENT HIST TABLE ENTRY OFFSET
         A     R2,HISTORY              POINT AT CURRENT ENTRY
         MVC   HISTCBHP,=X'7FFFFFFF'   SUPPRESS CB OVERLAY
         B     FORMAT                  GO SHOW STORAGE
         DROP  R5,R2
         SPACE 2
*----------------------------------------------------------------------
*
* DOWN -- SCROLL DOWN 256 BYTES OR NEXT CTRL BLK SEGMENT
*
*----------------------------------------------------------------------
         SPACE 2
DOWN     LLGH  R2,CURRENT              CURRENT HIST TABLE POINTER
         A     R2,HISTORY              POINT TO HIST TABLE ENTRY
         USING HIST,R2                 SETUP ENTRY FORMAT
         TM    HISTCBHP,X'80'          SEE IF THIS IS A CB DISPLAY
         BO    DOWNCB                  BR IF YES
         LG    R1,HISTADDR             ELSE GET ADDR TO SHOW 64 Bit Joe
         AH    R1,=H'256'              AND MOVE DOWN ONE SCREEN
         STG   R1,HISTADDR             AND REPLACE IN HIST TA64 Bit Joe
         B     FORMAT                  GO DISPLAY IT
DOWNCB   L     R1,HISTCBSP             GET CB SEGMENT ADDR
         L     R1,CBSNEXT-CBS(,R1)     GET NEXT SEG ADDR
         ST    R1,HISTCBSP             AND PUT IN HIST TABLE
         XC    HISTSADR,HISTSADR       CLEAR SEC SEG ADDR
         B     FORMAT                  GO SHOW IT
         DROP  R2
         SPACE 2
*----------------------------------------------------------------------
*
* UP   -- SCROLL UP   256 BYTES OR PREV CTRL BLK SEGMENT
*
*----------------------------------------------------------------------
         SPACE 2
UP       LLGH  R2,CURRENT              CURRENT HIST TABLE POINTER
         A     R2,HISTORY              POINT TO HIST TABLE ENTRY
         USING HIST,R2                 SETUP FORMAT OF ENTRY
         TM    HISTCBHP,X'80'          SEE IF THIS IS A CB DISPLAY
         BO    UPCB                    BR IF YES
         LG    R1,HISTADDR             ELSE GET ADDR TO SHOW 64 Bit Joe
         SH    R1,=H'256'              AND MOVE UP ONE SCREEN
         STG   R1,HISTADDR             AND REPLACE IN HIST TA64 Bit Joe
         B     FORMAT                  GO DISPLAY IT
UPCB     L     R1,HISTCBSP             GET CB SEGMENT ADDR
         L     R1,CBSPREV-CBS(,R1)     GET PREV SEG ADDR
         ST    R1,HISTCBSP             AND PUT IN HIST TABLE
         XC    HISTSADR,HISTSADR       CLEAR SEC SEG ADDR
         B     FORMAT                  GO SHOW IT
         DROP  R2
         SPACE 2
*----------------------------------------------------------------------
*
* REPEAT -- REPEAT LAST INPUT LINE
*
*----------------------------------------------------------------------
         SPACE 2
REPEAT   MVC   INPLINE(52),INPSAVE     COPY SAVED INPUT
         B     ISCAN2                  AND PROCESS IT
         SPACE 2
*----------------------------------------------------------------------
*
* LINK -- LINK TO LABELED CONTROL BLOCK FIELD
*
*----------------------------------------------------------------------
         SPACE 2
LINK     LH    R2,CURRENT              CURRENT HIST TABLE POINTER
         A     R2,HISTORY              POINT TO HIST TABLE ENTRY
         USING HIST,R2                 SETUP FORMAT OF ENTRY
         TM    HISTCBHP,X'80'          SEE IF CB FORMATTING IN USE
         BO    LINK2                   BR IF YES
LINKERR  MVC   MSGLINE,LINKMSG         NOTE ERROR IN LINK
         B     FORMAT                  AND RESHOW SCREEN
LINK2    L     R3,HISTCBSP             GET CURRENT CB SEG ADDRESS
         LA    R5,0(,R3)               CLEAR FLAGS AND SETUP FOR COMP
         USING CBS,R4
LINK2A   LR    R4,R3                   SAVE THE START OF SEG ADDR
         LA    R3,CBSLEN(,R3)          POINT PAST SEG HEADER
         USING CBF,R3
LINK3    CLC   CBFNAME(4),=F'0'        END OF SEGMENT
         BE    LINK4
         CLC   CBFNAME,INPLINE+1       DOES NAME MATCH
         BE    LINKFND                 IF SO THEN FOUND
         LA    R3,CBFLEN(,R3)          POINT PAST THIS ONE
         B     LINK3                   KEEP LOOKING
LINK4    DS    0H
         L     R3,CBSNEXT              POINT TO NEXT SEGMENT
         CR    R3,R5                   ARE WE BACK AT START
         BNE   LINK2A                  IF NOT KEEP GOING
         B     LINKERR                 IF NOT THEN ISSUE ERROR
         DROP  R4,R2
* A MATCH HAS  BEEN FOUND. FETCH THE  ADDRESS TO LINK TO
LINKFND  DS    0H
         SR    R0,R0                   CLEAR FOR IC
         IC    R0,CBFDLEN              LENGTH OF ITEM  MINUS 1
         LA    R1,DUMPDATA             ADDR TO PLACE DATA IN
         BAL   R14,GETCURAD            GET ADDR OF CURRENT SEGMENT
         AH    R2,CBFOFFS              OFFSET OF ITEM TO FETCH
         BAL   R14,GETSTOR             FETCH THE  ADDRESS
         B     LINKERR                 BR IF DATA CANT BE FETCHED
         B     LINKERR                 BR IF DATA CANT BE FETCHED
         BAL   R15,FWDSUB              UPDATE HIST TABLE TO NEXT
         L     R0,DUMPDATA             LOAD ADDRESS THAT WAS FETCHED
         SR    R15,R15                 NOW ADJUST THE
         IC    R15,CBFDLEN               FETCHED DATA
         LA    R1,4                        SO THAT
         SR    R1,R15                        IT IS RIGHT
         BNP   LF1                             JUSTIFIED IN
         SLL   R1,3                              REGISTER IF
         SRL   R0,0(R1)                            LESS THAN 4
LF1      DS    0H                                    BYTES
         LH    R2,CURRENT              NEW HIST TABLE POINTER
         A     R2,HISTORY              GET ENTRY ADDRESS
         USING HIST,R2
         STG   R0,HISTADDR             SAVE NEW ADDRESS     64 Bit Joe
         XC    HISTCBHP,HISTCBHP          AND
         XC    HISTCBSP,HISTCBSP            CLEAR
         XC    HISTSADR,HISTSADR               REST
         B     FORMAT                  GO FORMAT THE NEW CB
         DROP  R3,R2
         SPACE 2
*----------------------------------------------------------------------
*
*  SET INDIRECT FLAG
*
*----------------------------------------------------------------------
         SPACE 2
INDIR64  OI    FLAGS,IND64             SET FLAG
INDIR31  OI    FLAGS,IND31             SET FLAG
INDIR    OI    FLAGS,INDFLAG           SET FLAG
         LA    R3,1(,R3)               UPDATE SCAN POINTER
         CLI   INPLINE+1,C' '          USE CURRENT ADDRESS
         BNE   NUMSCAN                 IF NO, GO SCAN INPUT ADDRESS
         BAL   R14,GETCURAD
         LR    R4,R2                   MOVE TO RIGHT REGISTER
         B     ENDNUM
         SPACE 2
***********************************************************************
*
*  ESTABLISH SCREEN MODE
*
***********************************************************************
         SPACE 2
MODE     CLC   =C'1 ',INPLINE+1        MODE ONE TEST
         BE    MODE1                   BR IF YES
         CLC   =C'0 ',INPLINE+1        CHECK FOR MODE ZERO         1.1D
         BNE   INVAL                   IF NOT EITHER, INVALID
         NI    MODEFLAG,255-MIDDUMP    MODE 0 MEANS BACKUP 0
         B     FORMAT
MODE1    OI    MODEFLAG,MIDDUMP        MODE 1 MEANS BACK UP 7 LINES
         B     FORMAT
INVAL    MVC   MSGLINE,MODEMSG
         B     FORMAT
BADADDR  MVC   MSGLINE,INVADDR
         B     TPUTSCRN
PRGCHK   MVC   MSGLINE,PROGCHK
         B     TPUTSCRN
LOOKCHK  DS    0H
         L     R8,CSAWORK
         USING WORK,R8
         MVC   MSGLINE(L'LOOKABD),LOOKABD
         UNPK  WORKA(5),ABEND_CODE(3)
         TR    WORKA(5),HEXTAB
         MVC   MSGLINE+12(3),WORKA+1
         UNPK  WORKA(5),REACDE+1(3)
         TR    WORKA(5),HEXTAB
         MVC   MSGLINE+23(3),WORKA+2
         UNPK  WORKA,OFFSET+2(3)
         TR    WORKA,HEXTAB
         MVC   MSGLINE+34(4),WORKA+1
         B     TPUTSCRN
         SPACE 2
***********************************************************************
*
*  MANIPULATE HISTORY TABLE
*
***********************************************************************
         SPACE 2
FWD      BAL   R15,FWDSUB              FORWARD 1 IN HIST TABLE
         B     FORMAT
         SPACE
FWDSUB   LH    R1,CURRENT              CURRENT ENTRY INDEX
         LA    R1,HISTLEN(,R1)
         CH    R1,=AL2(50*HISTLEN)     SEE IF WRAP NEEDED
         BL    FWDEND                  BR IF NOT
         SR    R1,R1                   WRAP TO BEGINNING
FWDEND   STH   R1,CURRENT              STORE NEW OFFSET
         BR    R15                     RETURN TO CALLER
         SPACE 1
BACK     LH    R1,CURRENT
         SH    R1,=AL2(HISTLEN)        BACK UP ONE ENTRU
         BNM   BACKEND                 BR IF NO BACKWARD WRAP
         LA    R1,49*HISTLEN           ELSE GO TO END OF TABLE
BACKEND  STH   R1,CURRENT              SAVE RESULT
         B     FORMAT
         SPACE 2
***********************************************************************
*
*   ADD ENTRY TO SYMBOL TABLE
*
***********************************************************************
         SPACE 2
DEFINE   LA    R15,50                  NUMBER OF TABLE ENTRIES
         LA    R2,NAMES                START OF TABLE
DEFLOOP1 CLI   0(R2),X'0'              SEE IF UNUSED ENTRY
         BE    NSPACE                  BR IF SPACE FOUND
         LA    R2,12(,R2)              NEXT ENTRY ADDR
         BCT   R15,DEFLOOP1            TRY ALL ENTRIES
         MVC   MSGLINE,SYMFULL         TABLE IS FULL
         B     FORMAT
NSPACE   LA    R15,9                   MAX LENGTH +1
         LA    R0,INPLINE+1            ADDR OF FIRST BYTE
         LR    R1,R0                   COPY SYMBOL ADDR
DEFLOOP2 CLI   0(R1),C' '              SEE IF END OF SYM
         BE    DEFEND                  BR IF YES
         LA    R1,1(,R1)               POINT TO NEXT BYTE
         BCT   R15,DEFLOOP2            CONTINUE FOR 9 BYTES
DEFBAD   MVC   MSGLINE,DEFMSG          SYMBOL TOO LONG OR TOO SHORT
         B     FORMAT2                 DISPLAY WITH CURSOR AT ERROR
DEFEND   SR    R1,R0                   SYMBOL LENGTH
         BZ    DEFBAD                  NULL SYMBOL ILLEGAL
         BCTR  R1,R0                   FOR EXECUTE
         MVC   0(8,R2),=CL8' '         CLEAR TABLE ENTRY
         EX    R1,DEFMOVE              MOVE SYMBOL
         LH    R1,CURRENT              GET CURRENT ADDRESS
         A     R1,HISTORY
         LG    R1,HISTADDR-HIST(,R1)                         64 Bit Joe
         ST    R1,8(,R2)               STORE WITH SYMBOL
         B     FORMAT
DEFMOVE  MVC   0(0,R2),INPLINE+1       EXECUTED TO MOVE SYMBOL
         SPACE 2
***********************************************************************
*
*  SCAN THE ADDRESS EXPRESSION
* REGISTER USAGE
* R2 LAST NUMBER SCANNED
* R3 SCAN POINTER
* R4 CURRENT OUTPUT VALUE
* R5 LAST OPERATOR SCANNED
*
***********************************************************************
         SPACE 2
NUMSCAN  DS    0H
         BAL   R14,GETCURAD            CURRENT ENTRY IS DEFAULT
*        LR    R4,R2                   CURRENT ENTRY IS DEFAULT
         LGR   R4,R2                   CURRENT ENTRY IS      64 bit joe
         LA    R5,0                    ASSUME DEFAULT TO BE TAKEN
         CLI   0(R3),C'+'              SEE IF PREFIX PLUS
         BNE   NOTPLUS                 BR IF NOT
         LA    R5,4                    INDICATE PLUS OPERATOR
         B     NUMOP                   GO TO ADV POINTER
NOTPLUS  CLI   0(R3),C'-'              IS IT PREFIX MINUS
         BNE   NUMLOOP                 BR IF NOT, USE DEFAULT AS LOAD
         LA    R5,8                    INDICATE MINUS OPERATOR
NUMOP    LA    R3,1(,R3)               POINT TO NEXT INPUT BYTE
NUMLOOP  CLI   0(R3),C','              SEE IF NAME INDICATED
         BE    NAMESCAN                BR IF YES
         TRT   0(17,R3),NUMTAB          SEARCH FOR DELIMITER 64 bit Joe
         LR    R6,R3                   SAVE START OF NUMBER
         BC    8,BADSTUFF              BR IF INPUT TOO LONG
         LR    R3,R1                   UPDATE SCAN POINTER
         SR    R1,R6                   GET LENGTH OF INPUT
         BZ    BADSTUFF                BR IF ZERO INPUT
         MVC   TEMP1(16),=CL16' '       CLEAR TEMP AREA     64 bit  Joe
         LA    R15,TEMP1+16            RIGHT JUSTIFY INPUT  64 bit  Joe
         SR    R15,R1                  POINT TO RIGHT SPOT IN TEMP AREA
         BCTR  R1,0                    PREPARE FOR EX
         EX    R1,HEXMOVE              MOVE INPUT RIGHT JUSTIFIED
         TR    TEMP1(16),HEXTAB         TRANSLATE TO HEX    64 bit  Joe
         PACK  TEMP2(5),TEMP1(9)        CONVERT HEX TO BINA 64 bit  Joe
         MVC   TEMP3(4),TEMP2
         PACK  TEMP2(5),TEMP1+8(9)      CONVERT HEX TO BINA 64 bit  Joe
         MVC   TEMP3+4(4),TEMP2                             64 bit  Joe
         LG    R2,TEMP3                                     64 Bit  Joe
*        ICM   R2,15,TEMP2             NEW DISPLAY ADDRESS
         L     R8,CSAWORK              Get Csa Address
         USING WORK,R8                                      64 Bit  Joe
         STG   R2,START_ADDR           Starting Address
         MVC   LEN,=F'100'             ** Temp **
NUMDELIM EX    0,OPER(R5)              EXECUTE PREVIOUS OPERATOR
         CLI   0(R3),C' '              IS DELIM A BLANK
         BE    ENDNUM                  IF YES, END SCAN
         LA    R5,4                    PLUS OPERATOR CODE
         CLI   0(R3),C'+'              IS OPER L PLUS
         BE    NUMOP                   BR IF YES TO CONTINUE SAAN
         LA    R5,8                    MINUS CODE
         CLI   0(R3),C'-'              IS OPER MINUS
         BE    NUMOP                   BR IF YES
         MVC   MSGLINE,INVALOP         ELSE BAD DELIMITER
         B     FORMAT2                 DISPLAY WITH CURSOR AT ERROR
ENDNUM   TM    FLAGS,INDFLAG           IS THIS AN INDIRECT REQ
         BZ    NOTIND                  BR IF NOT
         TM    FLAGS,IND31+IND64       DO WE WANT 31 BIT INDI64 BIT JOE
         BNZ   *+8                     SKIP CLEAR IF YES
         ICM   R4,8,=X'00'             CLEAR TOP BYTE
*        LR    R2,R4                   SET ADDR TO GET FROM
         LGR   R2,R4                   SET ADDR TO GET   64 bit Joe
         TM    FLAGS,IND64             64 BIT ADDRESS    64 bit Joe
         BZ    GET31                                     64 Bit Joe
         LA    R0,8                    Address 64 bit    64 Bit Joe
         B     GOTOSTOR                Get the Address   64 bit Joe
GET31    DS    0H                                        64 Bit Joe
         LA    R0,4                    NUMBER OF BYTES TO64 bit Joe
GOTOSTOR DS    0H                                        64 Bit Joe
         LA    R1,DUMPDATA             WHERE TO PUT IT
         BAL   R14,GETSTOR             DO MEMORY FETCH
         B     BADIND                  NONE GOT
         B     BADIND                  SOME BUT NOT ALL GOT
         TM    FLAGS,IND64             64 BIT ADDRESS    64 bit Joe
         BZ    TRTONEAD                                  64 BIt Joe
         LG    R4,DUMPDATA             DO THE INDIRECT   64 bit Joe
         B     CKHIBIT                                   64 bit Joe
TRTONEAD DS    0H                                        64 Bit Joe
         LLGT  R4,DUMPDATA             DO THE INDIRECT   64 Bit Joe
* --->
CKHIBIT  DS    0H
         TM    FLAGS,AMOD64   BIGGER ADDRESS THAN 8 HEX BYTES?
         BO    KEEPHIG        DON'T NULLIFY BIT 0 OF 32
         CLMH  R4,15,=4X'00'  64 bit address                    Joe
         BNE   KEEPHIG        64 bit address                    Joe
         N     R4,=X'7FFFFFFF'         TURN OFF TOP BIT ALWAYS
KEEPHIG  DS    0H
* --->
NOTIND   BAL   R15,FWDSUB              UPDATE HISTORY POINTR
         LLGH  R2,CURRENT              NEW HIST TABLE POINTER64 Bit Joe
         A     R2,HISTORY              GET ENTRY ADDRESS
         USING HIST,R2
         STG   R4,HISTADDR             SAVE NEW ADDRESS      64 Bit Joe
         XC    HISTCBHP,HISTCBHP          AND
         XC    HISTCBSP,HISTCBSP            CLEAR
         XC    HISTSADR,HISTSADR               REST
         B     FORMAT
         DROP  R2
BADIND   MVC   MSGLINE,BADIMSG         MOVE IN MESSAGE
         B     FORMAT                  GO AND REDISPLAY
         SPACE 2
* SCAN INPUT FOR A NAME IN THE SYMBOL TABLE
NAMESCAN LA    R3,1(,R3)               SKIP OVER COMMA
         LR    R1,R3                   COPY INPUT POINTER
         LA    R15,9                   MAX LENGTH +1
NAMELOOP DS    0H
* --- >
         C     R15,=F'8'               MORE THAN 9 CHARACTERS?
         BH    FLAGSMAL                NO. NOT 64-BIT ADDRESS.
         OI    FLAGS,AMOD64            SHOW WE NEED HIGHER ADDRESS
FLAGSMAL DS    0H
* --- >
         CLI   0(R1),C'A'              SEE IF VALID CHAR
         BL    NAMEEND                 BR IF NOT, DELIM FOUND
         LA    R1,1(,R1)               POINT TO NEXT BYTE
         BCT   R15,NAMELOOP            ALLOW EIGHT BYTES PLUS DELIM
NAMEBAD  MVC   MSGLINE,NAMEMSG         NULL NAME OR NAME TOO LONG
         B     FORMAT2                 DISPLAY WITH CURSOR AT ERROR
NAMEEND  SR    R1,R3                   FIND LENGTH
         BZ    BADSTUFF                BR IF TOO SHORT
         MVC   TEMP1(8),=CL8' '        CLEA¢  WORK AREA
         BCTR  R1,0                    SET UP FOR EX
         EX    R1,NAMEMOVE             MOVE TO WORK AREA, BLANK PAD
         LA    R3,1(R3,R1)             UPDATE POINTER
         LA    R15,50                  ENTRIES IN SYM TABLE
         LA    R1,NAMES                START OF SYM TABLE
NAMELP2  CLC   TEMP1(8),0(R1)          SEE IF NAME IN TABLE
         BE    NAMEFIND                BR IF YES
         LA    R1,12(,R1)              POINT TO NEXT ENTRY
         BCT   R15,NAMELP2             BR IF ANY ENTRIES LEFT
         B     NAMEBAD                 BR IF NONE LEFT, UNDEFUNED SYM
NAMEFIND L     R2,8(,R1)               GET SYMBOL VALUE
         B     NUMDELIM                USE IN EXPRESSION
*  THESE INSTRUCTIONS ARE THE OBJECT OF AN EXECUTE
OPER     LGR   R4,R2                   USE HIST TABLE AS DEF64 Bit Joe
         AGR   R4,R2                   PLUS OPERATOR
         SGR   R4,R2                   MINUS OPERATOR
HEXMOVE  MVC   0(0,R15),0(R6)          RIGHT JUSTIFY INPUT DATA
NAMEMOVE MVC   TEMP1(1),0(R3)          PAD NAME WITH BLANKS BY MOVING
         SPACE
BADSTUFF MVC   MSGLINE,ERRMSG          NOTE BAD INPUT
         B     FORMAT2                 DISPLAY WITH CURSOR AT ERROR
         SPACE 2
         SPACE 2
*----------------------------------------------------------------------
*
* ERASE  --  CLEAR THE SCREEN BUFFER
*
*----------------------------------------------------------------------
         SPACE 2
ERASE    SAVE  (2,5)                   NEED SOME WORK REGS
         LA    R2,OUT1                 START OF AREA TO CLEAR
         LA    R3,80*16                LENGTH TO CLEAR
         LA    R5,C' '                 FILL CHAR
         SLL   R5,24                   MAKE PAD BYTE AND CLEAR SOURCE
         MVCL  R2,R4                   PROPAGATE BLANKS
         RETURN (2,5)                  RESTORE REGS AND RETURN
         EJECT
* EXECUTED INSTRUCTIONS AND CONSTANTS
CLEARMVC MVC   0(0,R6),BLANKS          CLEAR SOME SPACE
MOVEMVC  MVC   0(0,R15),1(R15)         MOVE DATA BACKWARDS
***********************************************************************
*
*
*        FETCH SOME STORAGE
*
*              R0  =  LENGTH TO FETCH <=4096 (MAXFETCH)
*              R1  => WHERE TO PUT IT
*              R2  => WHERE TO GET IT FROM
*
*
***********************************************************************
*ETSTOR  SAVE  (14,8)                  SAVE REGS
GETSTOR  STMG  R14,R8,24(R13)          SAVE REGS          64 bit   Joe
*        MODESET KEY=ZERO
         L     R8,CSAWORK              POINT TO CSA AREA            1.1
         USING WORK,R8                 SETUP ADDRESSABILITY         1.1
         MVI   MERRCD,0                INDICATE NO ERROR ON FETCH   1.1
         CLMH  R2,15,=4X'00'           Is top Part pop       64 bit Joe
         BNE   NOCLR64                 Dont CLear it         64 bit Joe
         LA    R2,0(0,R2)              clear top bit               1.1D
NOCLR64  DS    0H
         CL    R0,=A(MAXFETCH)         Max fetchable size          1.1D
         BL    *+8                     Requested ok                1.1D
         L     R0,=A(MAXFETCH)         Force smaller               1.1D
*
*        CHECK IF DATA IS IN BUFFER
*
         CLC   CSAASID,CURASID         WANT SAME ASID
         BNE   GETMORE                 NOPE
         CG    R2,CSASTAR              CHECK FOR BEGINNING 64 bit Joe
         BL    GETMORE
         LR    R15,R0                  GET LENGTH
         AGR   R15,R2                  GET END ADDRESS       64 Bit Joe
         CG    R15,CSAEND              CHECK FOR END         64 BIT Joe
         BH    GETMORE                 NOPE NOT IN BUFFER
         TM    FLAGS,RFRSH             IS IT REFRESH REQUEST
         BO    GETMORE                 REGET THE CORE
MOVEBUF  LG    R15,CSASTAR             GET VIRT ADDR OF BUFFE64 BIT jOE
         SGR   R2,R15                  GET DISPLACEMENT IN BU64 BIT JOE
         A     R2,CSABUF               POINT TO BUFFER
         LR    R3,R0                   MOVE LENGTH
         LR    R0,R1                   SET "TO" ADDR
         LR    R1,R3                   SET LENGTH
         MVCL  R0,R2
*        LM    R14,R8,12(R13)          RESTORE REGS                 1.1
         LMG   R14,R8,24(R13)          RESTORE REGS     64 BIT     Joe
         B     8(R14)                  RETURN ALL GOTTEN
GETMORE  DS    0H
         MVC   LENGTH,=F'2048'         Initial fetch is half page  1.1C
         C     R0,LENGTH               Is req for more than default1.1D
         BNH   *+8                     No  so skip                 1.1D
         ST    R0,LENGTH               Set first request for actual1.1D
         STG   R2,ADDR                 SAVE ADDR TO GET COR64 BIT Joe
         STG   R2,CSASTAR              SET CSA VIRT BUFFER 64 bit Joe
         NI    FLAGS,255-REFETCH       inidicate first fetch       1.1C
GETM2    DS    0H                                                  1.1C
         MVI   MERRCD,0                INDICATE NO ERROR ON FETCH  1.1C
         NI    FLAGS,255-RFRSH         TURN OFF FLAG
         MVC   CSAASID,CURASID         SET ASID OF CSABUFFER CONTENTS
         MVI   FLAG1,0                 CLEAR FLAGS
         MVI   FLAG2,0
         CLC   CURASID,MYASID          ARE WE IN THIS ADDR SPACE
         BNE   DOSRB                   IF NOT USE SRB
*
*        INVOKE SRB CODE AS SUBROUTINE
*
         OI    FLAG1,FG1SUBR           FLAG AS SUBROUTINE
         LA    R2,DMYPRMS              SETUP DUMMY FRR PARMS
*        TM    FLAGS,NOAUTH            ARE WE AUTHORIZIED          1Joe
*        BO    DOSUB1                  NO SO SKIP                  1Joe
         MODESET KEY=ZERO              GET TO KEY ZERO             1.1E
         SPKA  0                                                    Joe
DOSUB1   DS    0H                                                  1.1E
         XC    DMYPRMS,DMYPRMS
         LR    R1,R8                   SETUP PARM REGISTER
         ST    R7,SAVE7                Need another Base  64 bit   Joe
         LA    R15,D#SRBCD             SETUP ENTRY REGISTER
         MVC   RETRADDR,=A(RETRY0C4)
         MVC   RETRBAD,=A(FRRPOST)
         LA    R14,GOTBKSUB            SETUP RETURN REGISTER       1.1E
         OI    FLAGS,GETINPG           FLAG GETSTOR IN PROGRESS
         BR    R15                     GO TO IT
         BO    GOTBACK                 NO SO SKIP                  1.1E
GOTBKSUB DS    0H                                                   Joe
*        MODESET KEY=NZERO             GET TO TCB KEY              1.1E
         L     R7,SAVE7                Need another Base  64 bit   Joe
         B     GOTBACK                 CONTINUE                    1.1E
*
*        IF AUTHORIZED FOR SRB MODE ...
*
DOSRB    DS    0H                                                   Joe
*OSRB    TM    FLAGS,NOAUTH            ARE WE AUTHORIZED            Joe
*        BO    FAIL2                   NOPE                         Joe
*
*        VALIDATE ASID ...
*
         L     R2,CVTPTR               POINT TO CVT
         LH    R1,CSAASID              GET ASID
         L     R2,CVTASVT-CVTMAP(,R2)  POINT TO ASVT
         USING ASVT,R2                 SETUP ADDRESSABILITY
         C     R1,ASVTMAXU             IS IT TOO BIG
         BH    FAIL3                   SET INVALID ASID
         SLL   R1,2                    ASID*4
         LA    R1,ASVTENTY-4(R1)       POINT AT DESIRED ENTRY
*        MVC   TOASCB,0(R1)            SAVE ASCB ADDR
         L     R2,0(,R1)               GET ASCB ADDRESS
         L     R2,ASCBASSB-ASCB(,R2)   Get Assb
         MVC   TARGETSTOKN,ASSBSTKN-ASSB(R2)
         TM    TOASCB,ASVTAVAL         IS THIS ASCB EXISTENT
*        BO    FAIL3                   NOPE
         LA    R3,SRBAREA     POINT AT THE SRB
         DROP  R2
         L     R2,TOASCB               GET ASCB ADDR
         USING ASCB,R2                 SETUP ADDRESSABILITY
         TM    ASCBRCTF,ASCBOUT        IS ASCB SWPPED OUT
*        BO    FAIL3                   YES SO DONOT TRY TO TOUCH IT
         DROP  R2
*
*        INITIALIZE THE SRB AND INVOKE AS SRB
*
         TM    FLAGS,AMOD64   BIGGER ADDRESS THAN 8 HEX BYTES?
         BO    KEEPHIGH       DON'T NULLIFY BIT 0 OF 32
*        N     R0,=X'80000000'  LEAV ONLY ADDRESSING MODE      XA   1.1
KEEPHIGH DS    0H
         XC    ECB,ECB                 CLEAR THE ECBS FOR THE WAITLIST
         XC    ECB2,ECB2
         LA    R0,ECB
         LA    R1,ECB2
         STM   R0,R1,ECBLIST
         MVI   ECBLIST+4,X'80'
*
*        NOW ISSUE TIMER INCASE SRB NEVER POSTS US
*
*        STIMER REAL,D#STX,BINTVL==A(300)  WAIT 3 SECONDS
         MODESET KEY=ZERO
         SPKA  0                                                    Joe
         LA    R3,SRBCCD      POINT AT SRB CODE IN CSA         XA   1.1
         ST    R3,SRB_EPA
         LA    R5,RETRY0C4-D#SRBCD(R3)
         ST    R5,RETRADDR
         LA    R5,FRRPOST-D#SRBCD(R3)
         ST    R5,RETRBAD
         LA    R5,RECOVERY-D#SRBCD(,R3)
         ST    R5,FRR_EPA
         L     R2,USERSTOR                   Get Storage Key
         SLL   R2,4
         ST    R2,USERSTOR
         LA    R2,D#RMTR-D#SRBCD(,R3)  GET RESOURCE MGR TERMINATION
         ST    R2,RTM_EPA
         ST    R8,WORK_EPA
*
         IEAMSCHD EPADDR=SRB_EPA,                                      X
               ENV=STOKEN,                                             X
               TARGETSTOKEN=TARGETSTOKN,                               X
               PRIORITY=GLOBAL,                                        X
               FRRADDR=FRR_EPA,                                        X
               KEYVALUE=INVOKERKEY,                                    X
               RMTRADDR=RTM_EPA,                                       X
               PARM=WORK_EPA,                                          X
               SYNCH=YES
*
*        MODESET KEY=NZERO
*
*        WAIT  ECBLIST=ECBLIST
*        WAIT  ECB=ECB                                              Joe
*        TTIMER CANCEL
*
*        WE ARE BACK FROM EITHER TIMER OR SRB OR SUB
*
GOTBACK  L     R8,CSAWORK              POINT AT CSA AREA
         NI    FLAGS,255-GETINPG       TURN OFF GET IN PROGRESS
         TM    FLAG2,FG2ADDR
         BO    BADADDR
         TM    FLAG2,FG2PCK
         BO    PRGCHK
         TM    FLAG2,FLOOK
         BO    LOOKCHK
         TM    FLAG1,FG1SUBR           IS THIS A SUB CALL
         BO    GOTBK2                  IF SO IGNORE SOME ERRORS
         TM    FLAG1,FG1SRDN           DID SRB TERMINATE GOOD
         BZ    FAIL                    NOPE SO ERROR MSG
         TM    FLAG2,FG2PSTR+FG2PURG+FG2ERRR AN ERRORS
         BNZ   FAIL                    IF SO ERROR MESSAGE
GOTBK2   DS    0H
*
*        NOW MOVE INFO OUT OF CSA BUFFER
*
         LG    R2,24+24(,R13)          GET ORIG R1 INTO R2  64 bit Joe
         LG    R3,24+16(,R13)           GET DESIRED LENGTH  64 bit Joe
         L     R4,CSABUF               POINT TO BUFFER
         L     R5,LENGTH               GET ACTUAL LENGTH MOVED
         LTR   R5,R5                   Did any memory get back     1.1C
         BNZ   GOTBK4                  If so then use it           1.1C
         C     R3,=F'2048'             Was original req >= default 1.1C
         BNL   GOTBK4                  If so then cant get it      1.1C
         TM    FLAGS,REFETCH           Q. Is this first or sec ent 1.1C
         BO    GOTBK4                  A. Second, return no data   1.1C
         OI    FLAGS,REFETCH           First entry so indicate     1.1C
         ST    R3,LENGTH               Retry with orig req         1.1C
         B     GETM2                                               1.1C
GOTBK4   DS    0H                                                  1.1C
         NI    FLAGS,255-REFETCH       reset flag before return    1.1C
*
*        NOTE THAT ORIG(R2) IS EFFECTIVELY AT R4
*        FIRST BYTE DESIRED IS FIRST BYTE IN BUFFER
*
         MVCL  R2,R4                   MOVE IN CORE
         LG    R2,CSASTAR              GET START LOC        64 bit Joe
         A     R2,LENGTH               PLUS LENGTH MOVED
         STG   R2,CSAEND               SET CORRECT END ADDR  64 BIT Joe
         MVC   LOGOOD,CSASTAR          SET LOW RANGE DISPLAYABLE
         MVC   HIGOOD,CSAEND           AND HIGH RANGE
         MVC   12+12(4,R13),LENGTH     SET GOTTEN LENGTH
*                                                                   1.1
*        SET MESSAGE LINE TO INDICATE HOW SUCCESSFUL                1.1
*        THE MEMORY FETCH WAS                                       1.1
*                                                                   1.1
         CLI   MERRCD,4                IS THIS PROTECTION ERROR    1.1A
         BNE   GOTBK3A                 NO SO CHECK OTHERS          1.1A
         MVC   MSGLINE,PROT            MOVE IN PROTECTION MSG      1.1A
         B     GOTBK3                  ERROR SET                   1.1A
GOTBK3A  DS    0H                                                  1.1A
         CLI   MERRCD,X'11'            IS THIS A PAGE FAULT        1.1A
         BE    GOTBK3B                 YES                         1.1A
         CLI   MERRCD,X'10'            IS THIS A SEGMENT FAULT     1.1A
         BNE   GOTBK3                  NO                          1.1A
GOTBK3B  MVC   MSGLINE,NONEX           SET PAGE FAULT ERROR        1.1A
GOTBK3   DS    0H                                                   1.1
*        LM    R14,R8,12(R13)          RESTORE REGS
         LMG   R14,R8,24(R13)          RESTORE REGS       64 Bit Joe
         LTR   R1,R1                   ANY LENGTH GOTTEN
         BZR   R14                     IF NOT THEN EXIT +0
         CR    R0,R1                   ALL DESIRED GOTTEN
         BH    4(R14)                  IF NOT ALL THEN +4
         B     8(R14)                  ALL DESIRED GOTTEN THEN +8
*
*        IF ANY ERRORS GIVE ERROR MSG AND RETURN +0
*
FAIL     DS    0H
         DC    H'0'
         MVC   MSGLINE,SRBMSG          MOVE IN MESSAGE
         MVC   CURRENT+2(2),FLAG1
         B     FAILALL                 GO TO COMMON ROUTINE
*
*        IF NOT AUTHORIZED TO DISPLAY OTHER ASIDS GIVE MSG AND RESET
*
FAIL2    DS    0H
         MVC   MSGLINE,AUTHMSG         MOVE IN MESSAGE
         B     FAILALL                 GO TO COMMON ROUTINE
*
*        IF ASID IS NOT VALID OR SWAPPED OUT GIVE MSG AND RESET
*
FAIL3    DS    0H
         MVC   MSGLINE,BDASMSG         MOVE IN MESSAGE
FAILALL  DS    0H                      COMMON FAILURE ROUTINE
         MVC   CSASTAR,=D'0'           CLEAR THE START
         MVC   CSAEND,=D'0'              AND END ADDR
         MVC   CSAASID,=H'0'               AND THE ASID
         MVC   CURASID,MYASID          RESET ASID AVAIL
         RETURN (14,8)
KEY0     DC    X'00'
*
*        STIMER EXIT ROUTINE
*        ITS PURPOSE IS TO POST THE ECB AT ECB2 AND WAKE UP THE
*        LOOK PROCESSOR IF THE SRB FAILS.  TO DO THIS WE MUST
*        FIND THE ADDRESS OF THE ECB WHICH IS SAVED IN R3 OF
*        THE RB ABOVE THE WAIT.  IN THAT RB, R2 IS SET TO 'ABCD'.
*
         USING *,R12
D#STX    SAVE  (14,12)                 SAVE REGISTERS
         LR    R12,R15                 SET BASE REG
         L     R3,CVTPTR               POINT AT CVT
         L     R3,0(,R3)               POINT AT TCB WORDS
         L     R3,0(,R3)               POINT AT MY TCB
         L     R3,0(,R3)               POINT AT MY RB
         USING RBBASIC,R3
D#STX1   DS    0H                      NOW LOOK FOR KEY IN REG2
         CLC   RBGRS2,=C'ABCD'         IS THE KEY HERE
         BE    D#STX2                  YES
         TM    XSTAB2,RBTCBNXT         TEST TCB FLAG
         BO    D#STX3                  IF NOT FOUND PROPER RB
         L     R3,RBLINK               POINT AT PREVIOUS RB
         B     D#STX1
D#STX2   L     R2,RBGRS3               GET ADDR OF ECB TO POST
         POST  (R2)                    WAKE UP LOOK
         RETURN (14,12)
*
*        IF WE CANT FIND THE RB THEN DUMP
*
D#STX3   DC    H'0'
         DROP  R12,R3
         LTORG
         TITLE 'LOOK --  STORAGE ALTER/DISPLAY - SRB MODE CODE'
         DROP  R9
D#SRBCD  DS    0D
*
*        THIS CODE PERFORMS THE FOLLOWING FUNCTIONS
*              1 ESTABLISHES AN FRR FOR ERROR RECOVERY
*              2 VERIFIES THAT THE ADDRESSES THAT ARE NEEDED DO
*                EXIST.
*              3 PERFORM THE MODIFICATION IF ALLOW AND NECESSARY
*              4 SAVE THE PROPER CORE FOR DUMPING.
*              5 CROSS-MEMORY POST THE MAIN COMMAND PROCESSOR
*
         USING WORK,R8
         USING D#SRBCD,R7
         LR    R7,R15         SET THE BASE REGISTER
         USING PSA,0
         LLGTR R8,R1          SET THE MAIN PARM DSECT       64 bit Joe
*        ST    R2,FRRPRMS
         USING PSA,0
         CLC   PSATOLD,=F'0'
         BNE   IS_SUB
         ST    R8,0(R2)        Save work area
IS_SUB   DS    0H
         O     R14,=X'80000000'                             64 BIT Joe
         ST    R14,ASRBRTN    SAVE RETURN ADDR
*        L     R2,FRRPRMS     ACCESS THE 6 WORK PARM AREA
*        STM   R7,R8,0(R2)    SAVE BASE AND WORK REGS
*
*        MOVE MEMORY
*
*        DBGRDIE LINKAGE=BRANCH
RETRY0C4 L     R2,ADDR                 Test For 64 bit      64 bit Joe
         LTR   R2,R2                   64 BIT
         BZ    RGHTMODE                If high order
         XGR   R15,R15                                      64 Bit Joe
         LA    R15,RGHTMODE                                 64 Bit Joe
         OILL  R15,X'0001'                                  64 bit Joe
         BSM   0,R15                                        64 bit Joe
RGHTMODE DS    0H                                           64 bit Joe
         LG    R2,ADDR                 Other wise           64 bit Joe
         LA    R0,BUF                  POINT AT BUFFER
         L     R1,LENGTH               GET DESIRED LENGTH
         LR    R3,R1                   SET LENGTH
         OI    FLAG1,FG1MOVE           INDICATE IN MOVE
         MVCL  R0,R2                   MOVE IN CORE
         NI    FLAG1,255-FG1MOVE       NOTE NOT IN MOVE
*
*        NOW WE TERMINATE PROCESSING BY DOING A CROSS
*        MEMORY POST IF NOT IN SUBROUTINE MODE
*
FRRPOST  TM    FLAG1,FG1SUBR  IS THIS SUBROUTINE MODE
         BO    D#EXIT         IF SO THEN EXIT
*        L     R10,=A(X'40000000') SET CODE FOR POST                Joe
*        LR    R9,R8          SAVE WORK POINTER IN SAFE REG         Joe
*        LA    R11,ECB        ADDR OF ECB TO POST                   Joe
*        ICM   R11,8,=X'80'   FLAG AS XMPOST                        Joe
*        LA    R12,D#POSTR    SET POST ERROR RETURN                 Joe
*        L     R13,MYASCB     ASCB TO POST                          Joe
*        L     R15,CVTPTR     POINT AT CVT                          Joe
*        L     R15,CVT0PT01-CVTMAP(R15)    GET POST ENTRY POINTR    Joe
*        BALR  R14,R15        GO DO POST
*        DROP  R7             KILL MAIN ADDRESS
*        USING *,R14          SET TEMP BASE
*#PRTN   LR    R8,R9          RESET BASE OF WORK
*        SL    R14,=A(D#PRTN-D#SRBCD)  NOW HAVE CORRECTED BASE
*        LR    R7,R14         SET TO PROPER REG
*        DROP  R14
*        USING D#SRBCD,R7     RESET MAIN BASE
         OI    FLAG1,FG1SRDN  FLAG SRB AS COMPLETED
D#EXIT   L     R14,ASRBRTN    RESTORE RETURN ADDR
*        BR    R14            EXIT
         BSM   0,R14          EXIT                           64 bit Joe
*        COPY  DBGRLIT
         SPACE 5
*
*        POST ERROR ROUTINE  .. FLAG ERROR AND LET TIMER
*        WAKE UP TASK
*
*#POSTR  LR    R8,R9          RESET WORK BASE
*        OI    FLAG2,FG2PSTR  FLAG POST ERROR                       Joe
*        BR    R14            RETURN TO D#PRTN                      Joe
         TITLE 'LOOK --  Common Recovery Routine............'       Joe
RECOVERY DS    0D
***********************************************************************
*
*          Common Recovery Routine
*
***********************************************************************
         SPACE 2
         DROP  R9,R11
         USING *,R15               SET TEMP BASE
         C     R0,=F'12'
         BER   R14                 SKIP IF NOT SDWA
         DROP  R10
         LR    R4,R1                Save R1
         USING SDWA,R1
         L     R1,SDWAXPAD          Get Record Able Area
         DROP  R1
         USING SDWAPTRS,R1
         L     R1,SDWASRVP
         DROP  R1
         USING SDWARC1,R1
         CLI   SDWATYPE,SDWATFRR   Is This a FRR
         BNE   IS_ESTAE            No Must Be Is An Estae
         L     R2,0(,R2)           Address of 24 byte area
IS_ESTAE DS    0H
         LR    R8,R2
         ST    R14,RECOVRET
         USING SDWA,R4             SAVE ADDR
         LR    R12,R15             SAVE BASE REGISTER
         DROP  R15
         USING RECOVERY,R12
*        TM    FLAGS,GETINPG           IS A GETSTOR IN PROGRESS
*        BZ    SPIEOTR                 NOPE OTHER ERROR
*        L     R8,CSAWORK          SETUP REG 8
         USING WORK,R8                 IF FROM GETSTOR THEN R8 POINTS
*                                      TO WORK
*        TM    FLAG1,FG1MOVE           ARE WE IN MOVE INSTR
*        BZ    SPIEOTR                 NOPE
         MVC   MERRCD,SDWAICD1         SAVE INT CODE                1.1
         XR    R6,R6                   CLear R6
         ICM   R6,B'0011',SDWACMPC
         SRL   R6,4                    Shift Over
         STCM  R6,B'0011',ABEND_CODE
         CLC   ABEND_CODE,=X'00C4'     Soc4
         BNE   PROGCK
         CLI   SDWACRC+3,X'11'
         BNE   PROGCK
         CLC   RETRY,=F'5'
         BH    ERRMESS
         L     R3,SDWANXT1
         CLC   0(2,R3),=X'0E02'
         BNE   ERRMESS
         L     R1,LENGTH
         L     R2,SDWAGR01
         SR    R1,R2
         ST    R1,LENGTH
         B     SET_RP
ERRMESS  DS    0H
         MVC   RETRADDR,RETRBAD
         MVC   RETRY,=F'0'
         B     SET_RP
*        CLI   SDWAICD1-SDWA(R4),X'11' PIC 11
*        BNE   PROGCK                  IF NOT THEN TRY OTHERS
         OI    FLAG2,FG2ADDR
         B     SET_RP
PROGCK   DS    0H
         CLI   SDWATYPE,SDWATFRR       If this is not a Frr then look
         BNE   ITSLOOK                 No Must Be Is An Estae
*        OI    FLAG2,FG2PCK
         OI    FLAG2,FLOOK
         L     R6,SDWANXT1             Get Next Address
         L     R7,SDWAGR07             R11 Base Addrss Of Look
         SR    R6,R7
         ST    R6,OFFSET
         MVC   RETRADDR,RETRBAD
         MVC   REACDE,SDWACRC+1        Move reason code
         B     SET_RP
ITSLOOK  DS    0H
         OI    FLAG2,FLOOK
*        TM    SDWACMPF,SDWARCF        Is there a reason code
*        BZ    SETADDR                 No
         MVC   REACDE,SDWACRC+1        Move reason code
SETADDR  DS    0H
         L     R6,SDWANXT1             Get Next Address
         L     R7,SDWAGR11             R11 Base Addrss Of Look
         SR    R6,R7
         ST    R6,OFFSET
         MVC   RETRADDR,RETRBAD
         B     SET_RP
*
*        If We Have Gotten a S0C4 See if Storage is
*                  Swapped out
*
*        Issue all Flavors of VSMLOC to See if Storage
*
*                      Was Obtained
*
         L     R3,LEN
         LG    R2,START_ADDR
         MVC   LOC,=CL8'PRIVATE'
         VSMLOC PVT,AREA=((R2),(R3)),TCB=OWNTCB
         LTR    R15,R15          Q. Was Storage Obtained
         BZ     CK_PAGE          Is it paged in
*
*
*
         MVC   LOC,=CL8'SQA '
         VSMLOC SQA,AREA=((R2),(R3))
         LTR    R15,R15          Q. Was Storage Obtained
         BZ     CK_PAGE          Is it paged in
*
*
*
         MVC   LOC,=CL8'LSQA'
         VSMLOC LSQA,AREA=((R2),(R3))
         LTR    R15,R15          Q. Was Storage Obtained
         BZ     CK_PAGE          Is it paged in
*
*
*
         MVC   LOC,=CL8'CSA '
         VSMLOC CSA,AREA=((R2),(R3))
         LTR    R15,R15          Q. Was Storage Obtained
         BZ     CK_PAGE          Is it paged in
*
*
*
         MVC   LOC,=CL8'CPOOLFIX'
         VSMLOC CPOOLFIX,AREA=((R2))
         LTR    R15,R15          Q. Was Storage Obtained
         BZ     CK_PAGE          Is it paged in
*
*
*
         MVC   LOC,=CL8'CPOOLLCL'
         VSMLOC CPOOLLCL,AREA=((R2))
         LTR    R15,R15          Q. Was Storage Obtained
         BZ     CK_PAGE          Is it paged in
*
         OI     FLAG1,FG1NOAL    Indcate storage Not Allocated
         B      SETKEY0
*        B      D#EXIT
*
*        Check it storage is paged out
*
CK_PAGE  DS    0H
         STC   R0,SUBPOOL          Store Subpool value
         LG    R2,START_ADDR       Point to What we look at  64 bit Joe
         L     R3,USERSTOR         Get Storage Key
         SRL   R3,4                Put it back in right spot
*
         TPROT 0(R2),R3
         BC    14,MOVE_STOR
*
         LG    R2,START_ADDR                               64 bit Joe
         LGR   R3,R2                                       64 BIT jOE
         A     R3,LEN
*
SETKEY0  DS     0H
         SPKA   0                  We Have to Be In Stor Key 0
*
         LA    R3,40(,R2)
         PGSER R,FIX,A=(R2),EA=(R3),TCB=0,ECB=0,BRANCH=Y
*
MOVE_STOR DS   0H
         L     R2,LENGTH
         S     R2,SDWAGR01-SDWA(R1)    GET LENGTH NOT MOVED
         ST    R2,LENGTH               SAVE MOVED LENGTH
         B     D#FRR0                  ALL DONE
*        IF ADDRESSING EXCEPTION THEN
*        REGISTERS NOT ALWAYS UPDATED (PER POPS)
*        BUT THE TRANSLATION ADDR IS CLOSE.
*        ALSO NO DATA MAY HAVE BEEN MOVED.
*        (WE ARE DEALING HERE WITH WHAT MAY BE "MODEL DEPENDENT"
*        FEATURES)
D#FRR0A  DS    0H
         L     R2,SDWATRAN-SDWA(,R1)   GET BAD ADDRESS
         SG    R2,ADDR                 LESS START ADDR       64 BIT Joe
         LTR   R2,R2                   ANY GOOD LENGTH
         BM    D#FRR0                  NOPE                         1.1
         C     R2,LENGTH               MAKE SURE IT IS REASONABLE
         BH    D#FRR0                  SKIP IF NOT
         ST    R2,LENGTH               SAVE AS GOTTEN LENGTH
         LTR   R2,R2                   ANY LENGTH AT ALL            1.1
         BZ    D#FRR0                  NO - SO SKIP MOVE            1.1
         LR    R3,R2                   SETUP LENGTH
         LR    R5,R2                                               1.1C
         LG    R2,ADDR                 GET FROM ADDR         64 BIT Joe
         LA    R4,BUF                  GET TO ADDRESS              1.1C
         MVCL  R4,R2                                               1.1C
D#FRR0   OI    FLAG2,FG2IVLD  SET FLAG FOR MESSAGE
SET_RP   DS    0H
         LR    R1,R4
         DROP  R4
         USING SDWA,R1
         L     R7,SDWAGR07        Restore
         L     R4,RETRADDR
         MVC   REGS,SDWAGRSV
         MVC   REGS+8(4),ADDR+4
         SETRP RECORD=NO,RC=4,RETADDR=(R4),DUMP=NO,RETREGS=YES,        X
               FRESDWA=YES,RUB=REGUP
         LA    R15,4          Retry
         L     R14,RECOVRET   Restore Recovery
         BR    R14            EXIT
         SPACE 5
REGUP    DC    2X'FF'
REGS     DS    CL64
*
*        ALL OTHER ERRORS
*
D#FRR1   OI    FLAG2,FG2ERRR  SET FLAG FOR MESSAGES
         SETRP RECORD=YES,RC=4,RETADDR=FRRPOST,REGS,DUMP=YES,          X
               RETREGS=YES,FRESDWA=YES
         BR    R14            EXIT
SPIEOTR  DS    0H
         LR    R1,R4                   RESTORE SDWA REG
         SETRP REGS=(14,12),DUMP=NO,RC=0,RECORD=NO
         DROP  R12
         SPACE 2
         TITLE 'LOOK --  STORAGE ALTER/DISPLAY - RESOURCE MGR. CLEANUP'
*
*        THIS ROUTINE RECEIVES CONTROL IF THE SRB MUST BE
*        PURGED.
*
D#RMTR   DS    0H
         USING *,R15
         LR    R7,R15         SET BASE REGISTER
         SL    R7,=A(D#RMTR-D#SRBCD)   BY COMPUTATION
         DROP  R15
         USING D#SRBCD,R7
         LR    R8,R2          SET UP POINTER TO WORK
         ST    R14,ASRBRTN    SAVE RETURN ADDR
         OI    FLAG2,FG2PURG  SET PURGED
         B     FRRPOST        GO AND POST TO CLEAN UP
         LTORG
ENDSRB   DS    0H
SRBCODE  EQU   *-D#SRBCD               LENGTH OF SRB CODE
         TITLE 'LOOK --  STORAGE ALTER/DISPLAY - MESSAGES, CONSTANTS'
KEY1 DC CL80'1= HELP      2=           3= END        4=           5= REX
               PEAT  6=          '
KEY2 DC CL80'7= BACKWARD  8= FORWARD   9= HIST BWD  10= HIST FWD 11=   X
                    12=          '
* ERROR MESSAGE FOR BAD INPUT
TITLE    DC    CL79' '
MODEMSG  DC    CL79'***** INVALID MODE'
INVADDR  DC    CL79'***** BAD ADDRESS '
PROGCHK  DC    CL79'***** PROGRAM CHECK '
INVALOP  DC    CL79'***** INVALID OPERATOR'
SYMFULL  DC    CL79'***** SYMBOL TABLE IS FULL'
NAMEMSG  DC    CL79'***** UNDEFINED SYMBOL'
DEFMSG   DC    CL79'***** NULL SYMBOL OR SYMBOL TOO LONG'
PCMSG    DC    CL79'***** PROGRAM CHECK'
LINKMSG  DC    CL79'***** LINK FAILED'
SRBMSG   DC    CL79'***** SRB DATA FETCH FAILED'
AUTHMSG  DC    CL79'***** LOOK NOT CURRENTLY AUTHORIZED. REQUEST DENIEDX
               .'
BDASMSG  DC    CL79'***** ASID INVALID OR SWAPPED OUT.'
BADIMSG  DC    CL79'***** INDIRECT FAILED.'
ASIDFMT  DC    CL13'CURRENT ASID='
ERRMSG   DC    CL79'INVALID ADDRESS -- TRY AGAIN'
INVASIDC DC    CL79'INVALID CHARACTERS OR VALUE TYPED INTO ASID'
INVTYPDV DC    CL79'INACTIVE ASID TYPED IN'
PROT     DC    CL79'--- PART/ALL OF REQUESTED MEMORY FETCH PROTECTED' 1
NONEX    DC    CL79'--- PART/ALL OF REQUEST MEMORY NON-EXISTENT'    1.1
BLANKS   DC    CL79' '
         EJECT
HEXTAB   DC    256C' '                 GENERAL HEX CONVERSION TABLE
         ORG   HEXTAB+C'A'             INPUT CONVERSION
         DC    X'0A0B0C0D0E0F'
         ORG   HEXTAB+C'0'             OUTPUT CONVERSION
         DC    C'0123456789ABCDEF'
         ORG
* HEX INPUT TRT TABLE
NUMTAB   DC    256X'1'
         ORG   NUMTAB+C'A'
         DC    6X'0'
         ORG   NUMTAB+C'0'
         DC    10X'0'
         ORG
VALCHAR  DC    256C'.'                 TRANSLATE TO VALID CHARS
         ORG   VALCHAR+C' '
         DC    C' '
         ORG   VALCHAR+C'¢'
         DC    C'¢.<(+|&&'
         ORG   VALCHAR+C'!'
         DC    C'!$*);¬-/'
         ORG   VALCHAR+C','
         DC    C',%_.?'
         ORG   VALCHAR+C':'
         DC    C':#@''="'
         ORG   VALCHAR+C'a'
         DC    C'abcdefghi'
         ORG   VALCHAR+C'j'
         DC    C'jklmnopqr'
         ORG   VALCHAR+C's'
         DC    C'stuvwxyz'
         ORG   VALCHAR+C'A'
         DC    C'ABCDEFGHI'
         ORG   VALCHAR+C'J'
         DC    C'JKLMNOPQR'
         ORG   VALCHAR+C'S'
         DC    C'STUVWXYZ'
         ORG   VALCHAR+C'0'
         DC    C'0123456789'
         ORG
         LTORG
         SPACE 2
*        SCREEN DEFINITION AREA
QDINIT   DS    0D             START OS DISPLAY WORK AREA
         DC    F'0'           ORIG SCREEN DEPTH
         DC    F'0'           ORIG SCREEN LINESZ
         DC    H'80'          LENGTH OF DISPLAY LINE
         DC    PL2'21'        LINES PER SCREEN
         DS    0D
         DS    0CL69
         DC    CL6' '
         DC    CL63' '
         DC    CL63' '        CORRECTED DATA FROM SCREEN
         DS    0C             DISPLAY SCREEN
         DC    X'27'          CONTROL
         DC    X'F5'          ERASE/WRITE
         DC    X'C1115D7F1140403C404000' CLEAR SCREEN
         DC    CL43'LOOK COMMAND - DISPLAY VIRTUAL MEMORY' TITLE L 1.1D
         DC    CL13'DISPLAY ASID='
         DC    X'1DC8'        MARK NEXT FIELD AS INPUT FIELD
         DC    CL4' '         IN/OUT FOR ASID
         DC    X'1DF0'        TERMINATE INPUT FIELD
         DC    X'11'          SET BUFFER ADDRESS
         DC    X'C150'        (2,1)
         DC    C'ENTER CMD -'     REPLY PROMPT
         DC    X'1DC8'        MARK NEXT FIELD AS INPUT FIELD
         DC    X'13'          SET CURSOR ADDRESS
         DC    X'11'          SET BUFFER ADDRESS
         DC    X'C25B'        (2,76)
         DC    X'1DF0'        TERMINATE INPUT FIELD
         DC    X'11'          SET BUFFER ADDRESS
         DC    X'C260'        (3,1)
         DC    C'LAST CMD  - '
         DC    CL63' '        PREVIOUS COMMAND
         DC    X'11'          SET BUFFER ADDRESS
         DC    X'C3F0'        (4,1)
         DC    CL79' '
         DC    C' '
         DC    16CL80' '      MESSAGE TEXT AREA
         DC    2CL80' '
         DC    2CL80' '       PFK DISPLAY AREA
HELPMSG  DS    0H
 DC CL80'LOOK is a real time core display and formatting program. It alX
               so has the        '
 DC CL80'capability of displaying memory in any address space.         X
                                 '
 DC CL80'                                                              X
                                 '
 DC CL80'The valid commands are:                                       X
                                 '
 DC CL80'Iexp  24 bit indirect                 | Jexp  31 bit indirect X
                                 '
 DC CL80'(To change ASID, overtype it in hex.) | Gexp  64 bit indirect X
                                 '
 DC CL80'>     Forward                         | <     Backward        X
                                 '
 DC CL80'=sym  Define current address as "sym" | ,sym  Redisplay core aX
               t "sym"           '
 DC CL80'M0/M1 Flip between top and center     | Lname Indirect thru coX
               ntrol block field '
 DC CL80'Ocb   Format as "cb" control block    | R     Refresh displayeX
               d storage         '
 DC CL80'      "cb" may be NULL to show as hex |                       X
                                 '
 DC CL80'                                                              X
                                 '
 DC CL80'where ''exp'' is of the form:                                 X
                                   '
 DC CL80'    <+/->hhhh<+/-hhhh<+/-hhhh...>>                            X
                                 '
 DC CL80'and ''hhhh'' is a 1 to 8 digit hex number.                    X
                                   '
 DC CL80'                                                              X
                                 '
 DC CL80'                                                              X
                                 '
LOOKABD  DC    C' LOOK ABEND XXX REASON YYY OFFSET NNNN '
         TITLE 'LOOK --  STORAGE ALTER/DISPLAY - WORK AREAS, DSECTS'
*----------------------------------------------------------------------
*
* HIST -- HISTORY ENTRY FOR ONE OR MORE PREVIOUS ENTRIES
*
*----------------------------------------------------------------------
         SPACE 2
HIST     DSECT
HISTADDR DS    D                       ADDR OF STORAGE/MAIN CB ADDRES
HISTCBHP DS    A                       0 IF NO CB
*                                      X'7FFFFFFF' IF OVERLAY NULL
*                                      ADDR OF CBH IF CB DISPLAYED
HISTCBSP DS    A                       ADDR OF CBS DISPLAYED
HISTSADR DS    A                       ADDR OF STORAGE FOR THIS SEG
HISTLEN  EQU   *-HIST                  LENGTH OF ENTRY
         SPACE 5
*----------------------------------------------------------------------
*
* CBH  -- CONTROL BLOCK HEADER  -  ONE FOR EACH DIFFERENT CONTROL BLK
*
*----------------------------------------------------------------------
         SPACE 2
CBH      DSECT
CBHNEXT  DS    A                       ADDR OF NEXT CONTROL BLOCK OR 0
CBHVOFF  DS    A                       OFFSET OF VALIDATION FIELD
CBHCBSP  DS    A                       ADDR OF FIRST SEG DESCIPTOR
CBHNAME  DS    CL8                     NAME OF BLOCK
CBHVLEN  DS    X                       LENGTH OF VALIDATION FIELD
CBHVAL   DS    0X                      VALIDATION DATA
         SPACE 5
*----------------------------------------------------------------------
*
* CBS  -- CONTROL BLOCK SEGMENT
*
*----------------------------------------------------------------------
         SPACE 2
CBS      DSECT
CBSPREV  DS    A                       ADDRESS OF PREVIOUS SEGMENT
CBSNEXT  DS    A                       ADDRESS OF NEXT SEGMENT
CBSDLEN  DS    AL2                     LENGTH OF DATA TO FETCH
CBSDOFF  DS    AL2                     OFFSET OF DATA TO FETCH
CBSILEN  DS    AL2                     LENGTH OF INDIRECT TO FETCH
CBSIOFF  DS    AL2                     OFFSET OF INDIRECT TO FETCH
CBSLEN   EQU   *-CBS                   LENGTH OF SEGMENT HEADER
         SPACE 5
*----------------------------------------------------------------------
*
* CBF  -- CONTROL BLOCK FIELD
*
*----------------------------------------------------------------------
         SPACE 2
CBF      DSECT
CBFNAME  DS    CL8                     NAME OF FIELD
CBFTYPE  DS    CL1                     TYPE OF NAME
CBFDLEN  DS    XL1                     LENGTH OF DATA TO DISPLAY
CBFOFFS  DS    H                       OFFSET INTO BLOCK START
CBFLINE  DS    H                       LINE NUMBER TO PUT ON
CBFCOLM  DS    H                       COLUMN TO START IN
CBFLEN   EQU   *-CBF
         EJECT
*----------------------------------------------------------------------
*
*   MAIN DYNAMIC WORK AREA
*
*----------------------------------------------------------------------
WORKAREA DSECT
SAVE     DS    18D                                         64 BIT   Joe
SAVE14T1 DS    2D
OUTAREA  DS    CL80
SAVE7    DS    F
SAVE1    DS    F
HISTORY  DS    F                       HISTORY TABLE ADDRESS
TARGETSTOKN DS D
*RBRET   DS    F
*RBRETCODE DS  F
*RBRSN   DS    F
NAMES    DS    150D                    SYMBOL TABLE
CURRENT  DS    H                       HIST TABLE OFFSET
ESTAE    ESTAE 1,PARAM=0,MF=L      ROOM FOR ESTAE PARM LIST
         DS    0F,H                SPACER
ESRUB    DS    H                   BIT INDICATOR SHOULD BE X'0074'
BASE1    DS    F                   SECOND BASE REG (R9)
BASR10   DS    F                   NORMAL R10
BASE2    DS    F                   FIRST BASE REG (R11)
BASR13   DS    F                   NORMAL R13
TEMP1    DS    CL17                    CONVERSION WORK AREA  64 bit Joe
TEMP2    DS    CL9                     CONVERSION WORK AREA
TEMP3    DS    D                                             64 BIT Joe
LOGOOD   DC    D'0'                                          64 Bit Joe
HIGOOD   DC    XL8'FFFFFFFFFFFFF123'                         64 Bit Joe
CSALEN   DS    F                       SP AND LEN OF CSA WORK AREA
CSAWORK  DS    A                       ADDRESS OF CSA WORKAREA
CSABUF   DS    A                       ADDRESS OF CSA DATA BUFFER FOR
*                                      SRB
CSASTAR  DS    AD                      USERS ADDR OF BEGINNING OF
*                                      BUFFER DATA
CSAEND   DS    AD                      USERS ADDR OF END OF BUFFER DATA
CSAASID  DS    H                       USERS ASID FOR BUFFER DATA
MYASID   DS    H                       DCMS ASID
CURASID  DS    H                       DISPLAYED CORE ASID
WORKA    DS    CL6
SAVEASID DS    CL4                     FORMATTED VERSION OF CURASID
FLAGS    DS    X                       ASSORTED FLAGS
INDFLAG  EQU   X'80'                   INDIRECT IN PROGRESS
*OAUTH   EQU   X'40'                   IF ON THEN NOT AUTHORIZED    Joe
GETINPG  EQU   X'20'                   ON IF GETSTOR IN PROGRESS (SUBR)
RFRSH    EQU   X'10'                   ON TO REFRESH CSA BUFFER
IND31    EQU   X'08'                   31 BIT INDIRECT IN PROGRESS
REFETCH  EQU   X'04'                   First get failed and retry  1.1C
IND64    EQU   X'02'                   64 BIT INDIRECT IN PROGRESS
AMOD64   EQU   X'01'                   NEEDS ACCESS MODE 64
MODEFLAG DS    X                       USER OPTION FLAGS
MIDDUMP  EQU   X'80'                   ON TO FORCE DISPLAY BACK 8 LINES
ALIGN    EQU   X'40'                   ON TO ALIGN DUMP ON QUADWORD
         SPACE 2
*        SCREEN DEFINITION AREA
QDISPLAY DS    0D             START OS DISPLAY WORK AREA
QDOSZR0  DC    F'0'           ORIG SCREEN DEPTH
QDOSZR1  DC    F'0'           ORIG SCREEN LINESZ
QDLNELEN DC    H'80'          LENGTH OF DISPLAY LINE
QDLNES   DC    PL2'21'        LINES PER SCREEN
         DS    0D
PFREPLY  DS    0CL69
PFCODE   DC    CL6' '
PFTXT    DC    CL63' '
INPLINE  DC    CL63' '        CORRECTED DATA FROM SCREEN
QDSCREEN DS    0C             DISPLAY SCREEN
         DC    X'27'          CONTROL
         DC    X'F5'          ERASE/WRITE
         DC    X'C1115D7F1140403C404000' CLEAR SCREEN
         DC    CL43'LOOK COMMAND - DISPLAY VIRTUAL MEMORY' TITLE L 1.1D
ASIDLN   DC    CL13'CURRENT ASID='
         DC    X'1DC8'        MARK NEXT FIELD AS INPUT FIELD
ASIDLN1  DC    CL4' '         IN/OUT FOR ASID
         DC    X'1DF0'        TERMINATE INPUT FIELD
         DC    X'11'          SET BUFFER ADDRESS
         DC    X'C150'        (2,1)
         DC    C'ENTER CMD -'     REPLY PROMPT
         DC    X'1DC8'        MARK NEXT FIELD AS INPUT FIELD
         DC    X'13'          SET CURSOR ADDRESS
         DC    X'11'          SET BUFFER ADDRESS
         DC    X'C25B'        (2,76)
         DC    X'1DF0'        TERMINATE INPUT FIELD
         DC    X'11'          SET BUFFER ADDRESS
         DC    X'C260'        (3,1)
         DC    C'LAST CMD  - '
INPSAVE  DC    CL63' '        PREVIOUS COMMAND
         DC    X'11'          SET BUFFER ADDRESS
         DC    X'C3F0'        (4,1)
MSGLINE  DC    CL79' '
         DC    C' '
OUT1     DC    16CL80' '      MESSAGE TEXT AREA
OUT9     EQU   OUT1+(8*80)
         DC    2CL80' '
KEYS     DC    2CL80' '       PFK DISPLAY AREA
QDISPLN  EQU   *-QDISPLAY     LENGTH OF ENTIRE DISPLAY
QDSLNG   EQU   *-QDSCREEN     LENGTH OF SCREEN BUFFER
*
**       AREA TO HOLD DATA RETURNED BY GETSTOR
*
*        COPY  DBGRPY
DUMPDATA DS    XL(MAXFETCH)            DATA RETURNED BY GETSTOR
WORKLEN  EQU   *-WORKAREA
         EJECT
         PRINT NOGEN
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
*        END
         IHAASCB
         IHAASSB
         IHAASVT
         IHAFRRS
         IHAPSA
         IHAPVT
         IHASDWA
         IHASRB
         IHARB
         IHALCCA
         CVT   DSECT=YES
         EJECT
*
*        CSA AREA WORK AREA
*
WORK     DSECT
WORKSTRT DS    0D
DOUBLE   DS    2F
DMYPRMS  DS    6F             DUMMY AREA FOR FRR PARMS FOR SUBR MODE
SRB_EPA  DS    A
FRR_EPA  DS    A
RTM_EPA  DS    A
WORK_EPA DS    A
RECOVRET DS    F
ABEND_CODE DS  XL2
LOC      DS    CL8
START_ADDR DS  D                                             64 Bit Joe
LEN      DS    F
RETRADDR DS    A
RETRBAD  DS    A
RETRY    DS    F
OWNTCB   DS    F
FRRPRMS  DS    F              ADDRESS OF 6 WORD FRR PARM
ASRBRTN  DS    D              RETURN ADDR FOR SRB CODE       64 bit Joe
MYASCB   DS    F              ASCB ADDR OF MAIN ROUTINE
MYTCB    DS    F              TCB ADDRESS FOR MAIN ROUTINE
TOASCB   DS    F              ASCB ADDR OF SRB ROUTINE
ECB      DS    F              ECB FOR MAIN ROUTINE TO WAIT ON
ECB2     DS    F              ECB FOR STIMER TO POST
ECBLIST  DS    2F
LENGTH   DS    F              LENGTH OF STORAGE TO DUMP
USERSTOR DS    F              User Storage Key
SUBPOOL  DS    X
SRBAREA  DS    ((SRBSIZE+3)/4)F  THE SRB ITSELF
ADDR     DS    D              ADDRESS TO PROCESS AT
ASID     DS    H              ASID OF TOASCB
FLAG1    DS    X
FG1DUMP  EQU   X'80'
FG1REP   EQU   X'40'
FG1MOVE  EQU   X'20'                   IF ON DOING MVCL FOR DATA
FG1NOAL  EQU   X'10'
FG1SRDN  EQU   X'02'          IF ON SRB HAS TERMINATED
FG1SUBR  EQU   X'01'
FLAG2    DS    X
FG2NVER  EQU   X'01'          VERIFICATION FAILED
FG2IVLD  EQU   X'02'          VALIDATION FAILED
FG2ERRR  EQU   X'04'          DISASTER OCCURED IN SRB
FG2PURG  EQU   X'08'          SRB WAS PURGED
FG2ADDR  EQU   X'80'
FG2PCK   EQU   X'40'
FLOOK    EQU   X'20'
FG2PSTR  EQU   X'10'          IF ON THEN SRB POST HAD ERROR
REACDE   DS    CL3
OFFSET   DS    F
MERRCD   DS    X                       INTERRUPT CODE               1.1
SRBCCD   DS    0D                      ALIGN SRB CODE ON DBL WORD
         DS    (SRBCODE)X
         DS    0D                      ALIGN BUFFER
BUF      DS    (MAXFETCH)X
WORKLN   EQU   *-WORKSTRT
TRVALHEX CSECT
TRVALTAB DC    X'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'   00
         DC    X'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'   10
         DC    X'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'   20
         DC    X'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'   30
         DC    X'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'   40
         DC    X'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'   50
         DC    X'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'   60
         DC    X'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'   70
         DC    X'CCC1C2C3C4C5C6CCCCCCCCCCCCCCCCCC'   80
         DC    X'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'   90
         DC    X'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'   A0
         DC    X'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'   B0
         DC    X'CCC1C2C3C4C5C6CCCCCCCCCCCCCCCCCC'   C0
         DC    X'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'   D0
         DC    X'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'   E0
         DC    X'F0F1F2F3F4F5F6F7F8F9CCCCCCCCCCCC'   F0
         END
